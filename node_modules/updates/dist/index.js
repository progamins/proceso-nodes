#!/usr/bin/env node
import zn from "url";
import Wn from "fs";
import yn from "path";
import Ut, { argv as Yn, env as Ie, stdout as Zn, exit as ar, cwd as Qn } from "node:process";
import { dirname as kt, resolve as ze, basename as We, join as Vt } from "node:path";
import { readFileSync as lr, truncateSync as Jn, writeFileSync as es, lstatSync as cr, accessSync as ts } from "node:fs";
import rs from "node:os";
import ur from "node:tty";
import { execFileSync as ns } from "node:child_process";
function ss({ onlyFirst: e = !1 } = {}) {
  const t = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(t, e ? void 0 : "g");
}
function nt(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function is(e, t) {
  var r = e;
  t.slice(0, -1).forEach(function(i) {
    r = r[i] || {};
  });
  var n = t[t.length - 1];
  return n in r;
}
function fr(e) {
  return typeof e == "number" || /^0x[0-9a-f]+$/i.test(e) ? !0 : /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(e);
}
function pr(e, t) {
  return t === "constructor" && typeof e[t] == "function" || t === "__proto__";
}
var Rn = function(e, t) {
  t || (t = {});
  var r = {
    bools: {},
    strings: {},
    unknownFn: null
  };
  typeof t.unknown == "function" && (r.unknownFn = t.unknown), typeof t.boolean == "boolean" && t.boolean ? r.allBools = !0 : [].concat(t.boolean).filter(Boolean).forEach(function(T) {
    r.bools[T] = !0;
  });
  var n = {};
  function i(T) {
    return n[T].some(function(D) {
      return r.bools[D];
    });
  }
  Object.keys(t.alias || {}).forEach(function(T) {
    n[T] = [].concat(t.alias[T]), n[T].forEach(function(D) {
      n[D] = [T].concat(n[T].filter(function(U) {
        return D !== U;
      }));
    });
  }), [].concat(t.string).filter(Boolean).forEach(function(T) {
    r.strings[T] = !0, n[T] && [].concat(n[T]).forEach(function(D) {
      r.strings[D] = !0;
    });
  });
  var s = t.default || {}, o = { _: [] };
  function a(T, D) {
    return r.allBools && /^--[^=]+$/.test(D) || r.strings[T] || r.bools[T] || n[T];
  }
  function l(T, D, U) {
    for (var H = T, P = 0; P < D.length - 1; P++) {
      var L = D[P];
      if (pr(H, L))
        return;
      H[L] === void 0 && (H[L] = {}), (H[L] === Object.prototype || H[L] === Number.prototype || H[L] === String.prototype) && (H[L] = {}), H[L] === Array.prototype && (H[L] = []), H = H[L];
    }
    var E = D[D.length - 1];
    pr(H, E) || ((H === Object.prototype || H === Number.prototype || H === String.prototype) && (H = {}), H === Array.prototype && (H = []), H[E] === void 0 || r.bools[E] || typeof H[E] == "boolean" ? H[E] = U : Array.isArray(H[E]) ? H[E].push(U) : H[E] = [H[E], U]);
  }
  function u(T, D, U) {
    if (!(U && r.unknownFn && !a(T, U) && r.unknownFn(U) === !1)) {
      var H = !r.strings[T] && fr(D) ? Number(D) : D;
      l(o, T.split("."), H), (n[T] || []).forEach(function(P) {
        l(o, P.split("."), H);
      });
    }
  }
  Object.keys(r.bools).forEach(function(T) {
    u(T, s[T] === void 0 ? !1 : s[T]);
  });
  var c = [];
  e.indexOf("--") !== -1 && (c = e.slice(e.indexOf("--") + 1), e = e.slice(0, e.indexOf("--")));
  for (var d = 0; d < e.length; d++) {
    var g = e[d], h, b;
    if (/^--.+=/.test(g)) {
      var N = g.match(/^--([^=]+)=([\s\S]*)$/);
      h = N[1];
      var R = N[2];
      r.bools[h] && (R = R !== "false"), u(h, R, g);
    } else if (/^--no-.+/.test(g))
      h = g.match(/^--no-(.+)/)[1], u(h, !1, g);
    else if (/^--.+/.test(g))
      h = g.match(/^--(.+)/)[1], b = e[d + 1], b !== void 0 && !/^(-|--)[^-]/.test(b) && !r.bools[h] && !r.allBools && (!n[h] || !i(h)) ? (u(h, b, g), d += 1) : /^(true|false)$/.test(b) ? (u(h, b === "true", g), d += 1) : u(h, r.strings[h] ? "" : !0, g);
    else if (/^-[^-]+/.test(g)) {
      for (var I = g.slice(1, -1).split(""), C = !1, y = 0; y < I.length; y++) {
        if (b = g.slice(y + 2), b === "-") {
          u(I[y], b, g);
          continue;
        }
        if (/[A-Za-z]/.test(I[y]) && b[0] === "=") {
          u(I[y], b.slice(1), g), C = !0;
          break;
        }
        if (/[A-Za-z]/.test(I[y]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(b)) {
          u(I[y], b, g), C = !0;
          break;
        }
        if (I[y + 1] && I[y + 1].match(/\W/)) {
          u(I[y], g.slice(y + 2), g), C = !0;
          break;
        } else
          u(I[y], r.strings[I[y]] ? "" : !0, g);
      }
      h = g.slice(-1)[0], !C && h !== "-" && (e[d + 1] && !/^(-|--)[^-]/.test(e[d + 1]) && !r.bools[h] && (!n[h] || !i(h)) ? (u(h, e[d + 1], g), d += 1) : e[d + 1] && /^(true|false)$/.test(e[d + 1]) ? (u(h, e[d + 1] === "true", g), d += 1) : u(h, r.strings[h] ? "" : !0, g));
    } else if ((!r.unknownFn || r.unknownFn(g) !== !1) && o._.push(r.strings._ || !fr(g) ? g : Number(g)), t.stopEarly) {
      o._.push.apply(o._, e.slice(d + 1));
      break;
    }
  }
  return Object.keys(s).forEach(function(T) {
    is(o, T.split(".")) || (l(o, T.split("."), s[T]), (n[T] || []).forEach(function(D) {
      l(o, D.split("."), s[T]);
    }));
  }), t["--"] ? o["--"] = c.slice() : c.forEach(function(T) {
    o._.push(T);
  }), o;
};
const os = /* @__PURE__ */ nt(Rn);
function as(e) {
  return Buffer.from(e, "base64").toString("utf8");
}
function ls(e) {
  return Buffer.from(e, "utf8").toString("base64");
}
var cs = {
  decodeBase64: as,
  encodeBase64: ls
}, ve = {}, me = {}, hr;
function us() {
  if (hr) return me;
  hr = 1, me.parse = me.decode = n, me.stringify = me.encode = t, me.safe = s, me.unsafe = o;
  var e = typeof process < "u" && process.platform === "win32" ? `\r
` : `
`;
  function t(a, l) {
    var u = [], c = "";
    typeof l == "string" ? l = {
      section: l,
      whitespace: !1
    } : (l = l || {}, l.whitespace = l.whitespace === !0);
    var d = l.whitespace ? " = " : "=";
    return Object.keys(a).forEach(function(g, h, b) {
      var N = a[g];
      N && Array.isArray(N) ? N.forEach(function(R) {
        c += s(g + "[]") + d + s(R) + `
`;
      }) : N && typeof N == "object" ? u.push(g) : c += s(g) + d + s(N) + e;
    }), l.section && c.length && (c = "[" + s(l.section) + "]" + e + c), u.forEach(function(g, h, b) {
      var N = r(g).join("\\."), R = (l.section ? l.section + "." : "") + N, I = t(a[g], {
        section: R,
        whitespace: l.whitespace
      });
      c.length && I.length && (c += e), c += I;
    }), c;
  }
  function r(a) {
    return a.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(l) {
      return l.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
    });
  }
  function n(a) {
    var l = {}, u = l, c = null, d = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i, g = a.split(/[\r\n]+/g);
    return g.forEach(function(h, b, N) {
      if (!(!h || h.match(/^\s*[;#]/))) {
        var R = h.match(d);
        if (R) {
          if (R[1] !== void 0) {
            if (c = o(R[1]), c === "__proto__") {
              u = {};
              return;
            }
            u = l[c] = l[c] || {};
            return;
          }
          var I = o(R[2]);
          if (I !== "__proto__") {
            var C = R[3] ? o(R[4]) : !0;
            switch (C) {
              case "true":
              case "false":
              case "null":
                C = JSON.parse(C);
            }
            if (I.length > 2 && I.slice(-2) === "[]") {
              if (I = I.substring(0, I.length - 2), I === "__proto__")
                return;
              u[I] ? Array.isArray(u[I]) || (u[I] = [u[I]]) : u[I] = [];
            }
            Array.isArray(u[I]) ? u[I].push(C) : u[I] = C;
          }
        }
      }
    }), Object.keys(l).filter(function(h, b, N) {
      if (!l[h] || typeof l[h] != "object" || Array.isArray(l[h]))
        return !1;
      var R = r(h), I = l, C = R.pop(), y = C.replace(/\\\./g, ".");
      return R.forEach(function(T, D, U) {
        T !== "__proto__" && ((!I[T] || typeof I[T] != "object") && (I[T] = {}), I = I[T]);
      }), I === l && y === C ? !1 : (I[y] = l[h], !0);
    }).forEach(function(h, b, N) {
      delete l[h];
    }), l;
  }
  function i(a) {
    return a.charAt(0) === '"' && a.slice(-1) === '"' || a.charAt(0) === "'" && a.slice(-1) === "'";
  }
  function s(a) {
    return typeof a != "string" || a.match(/[=\r\n]/) || a.match(/^\[/) || a.length > 1 && i(a) || a !== a.trim() ? JSON.stringify(a) : a.replace(/;/g, "\\;").replace(/#/g, "\\#");
  }
  function o(a, l) {
    if (a = (a || "").trim(), i(a)) {
      a.charAt(0) === "'" && (a = a.substr(1, a.length - 2));
      try {
        a = JSON.parse(a);
      } catch {
      }
    } else {
      for (var u = !1, c = "", d = 0, g = a.length; d < g; d++) {
        var h = a.charAt(d);
        if (u)
          "\\;#".indexOf(h) !== -1 ? c += h : c += "\\" + h, u = !1;
        else {
          if (";#".indexOf(h) !== -1)
            break;
          h === "\\" ? u = !0 : c += h;
        }
      }
      return u && (c += "\\"), c.trim();
    }
    return a;
  }
  return me;
}
var gt, dr;
function fs() {
  if (dr) return gt;
  dr = 1;
  var e = 1, t = 2;
  function r() {
    return "";
  }
  function n(i, s, o) {
    return i.slice(s, o).replace(/\S/g, " ");
  }
  return gt = function(i, s) {
    s = s || {};
    for (var o, a, l = !1, u = !1, c = 0, d = "", g = s.whitespace === !1 ? r : n, h = 0; h < i.length; h++) {
      if (o = i[h], a = i[h + 1], !u && o === '"') {
        var b = i[h - 1] === "\\" && i[h - 2] !== "\\";
        b || (l = !l);
      }
      if (!l) {
        if (!u && o + a === "//")
          d += i.slice(c, h), c = h, u = e, h++;
        else if (u === e && o + a === `\r
`) {
          h++, u = !1, d += g(i, c, h), c = h;
          continue;
        } else if (u === e && o === `
`)
          u = !1, d += g(i, c, h), c = h;
        else if (!u && o + a === "/*") {
          d += i.slice(c, h), c = h, u = t, h++;
          continue;
        } else if (u === t && o + a === "*/") {
          h++, u = !1, d += g(i, c, h + 1), c = h + 1;
          continue;
        }
      }
    }
    return d + (u ? g(i.substr(c)) : i.substr(c));
  }, gt;
}
var gr;
function ps() {
  if (gr) return ve;
  gr = 1;
  var e = Wn, t = us(), r = yn, n = fs(), i = ve.parse = function(o) {
    return /^\s*{/.test(o) ? JSON.parse(n(o)) : t.parse(o);
  }, s = ve.file = function() {
    var o = [].slice.call(arguments).filter(function(u) {
      return u != null;
    });
    for (var a in o)
      if (typeof o[a] != "string")
        return;
    var l = r.join.apply(null, o);
    try {
      return e.readFileSync(l, "utf-8");
    } catch {
      return;
    }
  };
  return ve.json = function() {
    var o = s.apply(null, arguments);
    return o ? i(o) : null;
  }, ve.env = function(o, a) {
    a = a || process.env;
    var l = {}, u = o.length;
    for (var c in a)
      if (c.toLowerCase().indexOf(o.toLowerCase()) === 0) {
        for (var d = c.substring(u).split("__"), g; (g = d.indexOf("")) > -1; )
          d.splice(g, 1);
        var h = l;
        d.forEach(function(N, R) {
          !N || typeof h != "object" || (R === d.length - 1 && (h[N] = a[c]), h[N] === void 0 && (h[N] = {}), h = h[N]);
        });
      }
    return l;
  }, ve.find = function() {
    var o = r.join.apply(null, [].slice.call(arguments));
    function a(l, u) {
      var c = r.join(l, u);
      try {
        return e.statSync(c), c;
      } catch {
        if (r.dirname(l) !== l)
          return a(r.dirname(l), u);
      }
    }
    return a(process.cwd(), o);
  }, ve;
}
var Et = { exports: {} };
var Er;
function hs() {
  if (Er) return Et.exports;
  Er = 1;
  function e(s) {
    return s instanceof Buffer || s instanceof Date || s instanceof RegExp;
  }
  function t(s) {
    if (s instanceof Buffer) {
      var o = Buffer.alloc ? Buffer.alloc(s.length) : new Buffer(s.length);
      return s.copy(o), o;
    } else {
      if (s instanceof Date)
        return new Date(s.getTime());
      if (s instanceof RegExp)
        return new RegExp(s);
      throw new Error("Unexpected situation");
    }
  }
  function r(s) {
    var o = [];
    return s.forEach(function(a, l) {
      typeof a == "object" && a !== null ? Array.isArray(a) ? o[l] = r(a) : e(a) ? o[l] = t(a) : o[l] = i({}, a) : o[l] = a;
    }), o;
  }
  function n(s, o) {
    return o === "__proto__" ? void 0 : s[o];
  }
  var i = Et.exports = function() {
    if (arguments.length < 1 || typeof arguments[0] != "object")
      return !1;
    if (arguments.length < 2)
      return arguments[0];
    var s = arguments[0], o = Array.prototype.slice.call(arguments, 1), a, l;
    return o.forEach(function(u) {
      typeof u != "object" || u === null || Array.isArray(u) || Object.keys(u).forEach(function(c) {
        if (l = n(s, c), a = n(u, c), a !== s)
          if (typeof a != "object" || a === null) {
            s[c] = a;
            return;
          } else if (Array.isArray(a)) {
            s[c] = r(a);
            return;
          } else if (e(a)) {
            s[c] = t(a);
            return;
          } else if (typeof l != "object" || l === null || Array.isArray(l)) {
            s[c] = i({}, a);
            return;
          } else {
            s[c] = i(l, a);
            return;
          }
      });
    }), s;
  };
  return Et.exports;
}
var mt, mr;
function An() {
  if (mr) return mt;
  mr = 1;
  var e = ps(), t = yn.join, r = hs(), n = "/etc", i = process.platform === "win32", s = i ? process.env.USERPROFILE : process.env.HOME;
  return mt = function(o, a, l, u) {
    if (typeof o != "string")
      throw new Error("rc(name): name *must* be string");
    l || (l = Rn(process.argv.slice(2))), a = (typeof a == "string" ? e.json(a) : a) || {}, u = u || e.parse;
    var c = e.env(o + "_"), d = [a], g = [];
    function h(b) {
      if (!(g.indexOf(b) >= 0)) {
        var N = e.file(b);
        N && (d.push(u(N)), g.push(b));
      }
    }
    return i || [
      t(n, o, "config"),
      t(n, o + "rc")
    ].forEach(h), s && [
      t(s, ".config", o, "config"),
      t(s, ".config", o),
      t(s, "." + o, "config"),
      t(s, "." + o + "rc")
    ].forEach(h), h(e.find("." + o + "rc")), c.config && h(c.config), l.config && h(l.config), r.apply(null, d.concat([
      c,
      l,
      g.length ? { configs: g, config: g[g.length - 1] } : void 0
    ]));
  }, mt;
}
var $t = zn, wn = cs, ds = wn.decodeBase64, gs = wn.encodeBase64, $r = ":_authToken", vr = ":_auth", yr = ":username", Rr = ":_password", Es = function() {
  var e, t;
  return arguments.length >= 2 ? (e = arguments[0], t = arguments[1]) : typeof arguments[0] == "string" ? e = arguments[0] : t = arguments[0], t = t || {}, t.npmrc = t.npmrc || An()("npm", { registry: "https://registry.npmjs.org/" }, {
    config: process.env.npm_config_userconfig || process.env.NPM_CONFIG_USERCONFIG
  }), e = e || t.npmrc.registry, _n(e, t) || ms(t.npmrc);
};
function _n(e, t) {
  for (var r = $t.parse(e, !1, !0), n; n !== "/" && r.pathname !== n; ) {
    n = r.pathname || "/";
    var i = "//" + r.host + n.replace(/\/$/, ""), s = vs(i, t.npmrc);
    if (s)
      return s;
    if (!t.recursive)
      return /\/$/.test(e) ? void 0 : _n($t.resolve(e, "."), t);
    r.pathname = $t.resolve($s(n), "..") || "/";
  }
}
function ms(e) {
  if (e._auth) {
    var t = st(e._auth);
    return { token: t, type: "Basic" };
  }
}
function $s(e) {
  return e[e.length - 1] === "/" ? e : e + "/";
}
function vs(e, t) {
  var r = ys(t[e + $r] || t[e + "/" + $r]);
  if (r)
    return r;
  var n = t[e + yr] || t[e + "/" + yr], i = t[e + Rr] || t[e + "/" + Rr], s = Rs(n, i);
  if (s)
    return s;
  var o = As(t[e + vr] || t[e + "/" + vr]);
  if (o)
    return o;
}
function st(e) {
  return e.replace(/^\$\{?([^}]*)\}?$/, function(t, r) {
    return process.env[r];
  });
}
function ys(e) {
  if (e) {
    var t = st(e);
    return { token: t, type: "Bearer" };
  }
}
function Rs(e, t) {
  if (!(!e || !t)) {
    var r = ds(st(t)), n = gs(e + ":" + r);
    return {
      token: n,
      type: "Basic",
      password: r,
      username: e
    };
  }
}
function As(e) {
  if (e) {
    var t = st(e);
    return { token: t, type: "Basic" };
  }
}
const vt = /* @__PURE__ */ nt(Es);
var ws = An();
const _s = /* @__PURE__ */ nt(ws);
var Ht = { exports: {} };
const Ss = "2.0.0", bs = 256, Os = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, Ts = 16;
var it = {
  SEMVER_SPEC_VERSION: Ss,
  MAX_LENGTH: bs,
  MAX_SAFE_INTEGER: Os,
  MAX_SAFE_COMPONENT_LENGTH: Ts
};
const Is = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
var ot = Is;
(function(e, t) {
  const { MAX_SAFE_COMPONENT_LENGTH: r } = it, n = ot;
  t = e.exports = {};
  const i = t.re = [], s = t.src = [], o = t.t = {};
  let a = 0;
  const l = (u, c, d) => {
    const g = a++;
    n(u, g, c), o[u] = g, s[g] = c, i[g] = new RegExp(c, d ? "g" : void 0);
  };
  l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${s[o.NUMERICIDENTIFIER]})\\.(${s[o.NUMERICIDENTIFIER]})\\.(${s[o.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${s[o.NUMERICIDENTIFIERLOOSE]})\\.(${s[o.NUMERICIDENTIFIERLOOSE]})\\.(${s[o.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${s[o.NUMERICIDENTIFIER]}|${s[o.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${s[o.NUMERICIDENTIFIERLOOSE]}|${s[o.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${s[o.PRERELEASEIDENTIFIER]}(?:\\.${s[o.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${s[o.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${s[o.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${s[o.BUILDIDENTIFIER]}(?:\\.${s[o.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${s[o.MAINVERSION]}${s[o.PRERELEASE]}?${s[o.BUILD]}?`), l("FULL", `^${s[o.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${s[o.MAINVERSIONLOOSE]}${s[o.PRERELEASELOOSE]}?${s[o.BUILD]}?`), l("LOOSE", `^${s[o.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${s[o.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${s[o.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${s[o.XRANGEIDENTIFIER]})(?:\\.(${s[o.XRANGEIDENTIFIER]})(?:\\.(${s[o.XRANGEIDENTIFIER]})(?:${s[o.PRERELEASE]})?${s[o.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${s[o.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[o.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[o.XRANGEIDENTIFIERLOOSE]})(?:${s[o.PRERELEASELOOSE]})?${s[o.BUILD]}?)?)?`), l("XRANGE", `^${s[o.GTLT]}\\s*${s[o.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${s[o.GTLT]}\\s*${s[o.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?(?:$|[^\\d])`), l("COERCERTL", s[o.COERCE], !0), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${s[o.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", l("TILDE", `^${s[o.LONETILDE]}${s[o.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${s[o.LONETILDE]}${s[o.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${s[o.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", l("CARET", `^${s[o.LONECARET]}${s[o.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${s[o.LONECARET]}${s[o.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${s[o.GTLT]}\\s*(${s[o.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${s[o.GTLT]}\\s*(${s[o.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${s[o.GTLT]}\\s*(${s[o.LOOSEPLAIN]}|${s[o.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${s[o.XRANGEPLAIN]})\\s+-\\s+(${s[o.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${s[o.XRANGEPLAINLOOSE]})\\s+-\\s+(${s[o.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(Ht, Ht.exports);
var Ce = Ht.exports;
const xs = ["includePrerelease", "loose", "rtl"], Ns = (e) => e ? typeof e != "object" ? { loose: !0 } : xs.filter((t) => e[t]).reduce((t, r) => (t[r] = !0, t), {}) : {};
var at = Ns;
const Ar = /^[0-9]+$/, Sn = (e, t) => {
  const r = Ar.test(e), n = Ar.test(t);
  return r && n && (e = +e, t = +t), e === t ? 0 : r && !n ? -1 : n && !r ? 1 : e < t ? -1 : 1;
}, Cs = (e, t) => Sn(t, e);
var bn = {
  compareIdentifiers: Sn,
  rcompareIdentifiers: Cs
};
const Ve = ot, { MAX_LENGTH: wr, MAX_SAFE_INTEGER: Xe } = it, { re: _r, t: Sr } = Ce, Ls = at, { compareIdentifiers: Se } = bn;
let Ps = class le {
  constructor(t, r) {
    if (r = Ls(r), t instanceof le) {
      if (t.loose === !!r.loose && t.includePrerelease === !!r.includePrerelease)
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(`Invalid Version: ${t}`);
    if (t.length > wr)
      throw new TypeError(
        `version is longer than ${wr} characters`
      );
    Ve("SemVer", t, r), this.options = r, this.loose = !!r.loose, this.includePrerelease = !!r.includePrerelease;
    const n = t.trim().match(r.loose ? _r[Sr.LOOSE] : _r[Sr.FULL]);
    if (!n)
      throw new TypeError(`Invalid Version: ${t}`);
    if (this.raw = t, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > Xe || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Xe || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Xe || this.patch < 0)
      throw new TypeError("Invalid patch version");
    n[4] ? this.prerelease = n[4].split(".").map((i) => {
      if (/^[0-9]+$/.test(i)) {
        const s = +i;
        if (s >= 0 && s < Xe)
          return s;
      }
      return i;
    }) : this.prerelease = [], this.build = n[5] ? n[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if (Ve("SemVer.compare", this.version, this.options, t), !(t instanceof le)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new le(t, this.options);
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return t instanceof le || (t = new le(t, this.options)), Se(this.major, t.major) || Se(this.minor, t.minor) || Se(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof le || (t = new le(t, this.options)), this.prerelease.length && !t.prerelease.length)
      return -1;
    if (!this.prerelease.length && t.prerelease.length)
      return 1;
    if (!this.prerelease.length && !t.prerelease.length)
      return 0;
    let r = 0;
    do {
      const n = this.prerelease[r], i = t.prerelease[r];
      if (Ve("prerelease compare", r, n, i), n === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === i)
        continue;
      return Se(n, i);
    } while (++r);
  }
  compareBuild(t) {
    t instanceof le || (t = new le(t, this.options));
    let r = 0;
    do {
      const n = this.build[r], i = t.build[r];
      if (Ve("prerelease compare", r, n, i), n === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === i)
        continue;
      return Se(n, i);
    } while (++r);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(t, r) {
    switch (t) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", r);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", r);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", r), this.inc("pre", r);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", r), this.inc("pre", r);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          let n = this.prerelease.length;
          for (; --n >= 0; )
            typeof this.prerelease[n] == "number" && (this.prerelease[n]++, n = -2);
          n === -1 && this.prerelease.push(0);
        }
        r && (Se(this.prerelease[0], r) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [r, 0]) : this.prerelease = [r, 0]);
        break;
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return this.format(), this.raw = this.version, this;
  }
};
var re = Ps;
const { MAX_LENGTH: Ds } = it, { re: br, t: Or } = Ce, Tr = re, Hs = at, js = (e, t) => {
  if (t = Hs(t), e instanceof Tr)
    return e;
  if (typeof e != "string" || e.length > Ds || !(t.loose ? br[Or.LOOSE] : br[Or.FULL]).test(e))
    return null;
  try {
    return new Tr(e, t);
  } catch {
    return null;
  }
};
var Le = js;
const Gs = Le, Bs = (e, t) => {
  const r = Gs(e, t);
  return r ? r.version : null;
};
var Fs = Bs;
const Ms = Le, Us = (e, t) => {
  const r = Ms(e.trim().replace(/^[=v]+/, ""), t);
  return r ? r.version : null;
};
var ks = Us;
const Ir = re, Vs = (e, t, r, n) => {
  typeof r == "string" && (n = r, r = void 0);
  try {
    return new Ir(
      e instanceof Ir ? e.version : e,
      r
    ).inc(t, n).version;
  } catch {
    return null;
  }
};
var Xs = Vs;
const xr = re, qs = (e, t, r) => new xr(e, r).compare(new xr(t, r));
var oe = qs;
const Ks = oe, zs = (e, t, r) => Ks(e, t, r) === 0;
var Xt = zs;
const Nr = Le, Ws = Xt, Ys = (e, t) => {
  if (Ws(e, t))
    return null;
  {
    const r = Nr(e), n = Nr(t), i = r.prerelease.length || n.prerelease.length, s = i ? "pre" : "", o = i ? "prerelease" : "";
    for (const a in r)
      if ((a === "major" || a === "minor" || a === "patch") && r[a] !== n[a])
        return s + a;
    return o;
  }
};
var Zs = Ys;
const Qs = re, Js = (e, t) => new Qs(e, t).major;
var ei = Js;
const ti = re, ri = (e, t) => new ti(e, t).minor;
var ni = ri;
const si = re, ii = (e, t) => new si(e, t).patch;
var oi = ii;
const ai = Le, li = (e, t) => {
  const r = ai(e, t);
  return r && r.prerelease.length ? r.prerelease : null;
};
var ci = li;
const ui = oe, fi = (e, t, r) => ui(t, e, r);
var pi = fi;
const hi = oe, di = (e, t) => hi(e, t, !0);
var gi = di;
const Cr = re, Ei = (e, t, r) => {
  const n = new Cr(e, r), i = new Cr(t, r);
  return n.compare(i) || n.compareBuild(i);
};
var qt = Ei;
const mi = qt, $i = (e, t) => e.sort((r, n) => mi(r, n, t));
var vi = $i;
const yi = qt, Ri = (e, t) => e.sort((r, n) => yi(n, r, t));
var Ai = Ri;
const wi = oe, _i = (e, t, r) => wi(e, t, r) > 0;
var lt = _i;
const Si = oe, bi = (e, t, r) => Si(e, t, r) < 0;
var Kt = bi;
const Oi = oe, Ti = (e, t, r) => Oi(e, t, r) !== 0;
var On = Ti;
const Ii = oe, xi = (e, t, r) => Ii(e, t, r) >= 0;
var zt = xi;
const Ni = oe, Ci = (e, t, r) => Ni(e, t, r) <= 0;
var Wt = Ci;
const Li = Xt, Pi = On, Di = lt, Hi = zt, ji = Kt, Gi = Wt, Bi = (e, t, r, n) => {
  switch (t) {
    case "===":
      return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e === r;
    case "!==":
      return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e !== r;
    case "":
    case "=":
    case "==":
      return Li(e, r, n);
    case "!=":
      return Pi(e, r, n);
    case ">":
      return Di(e, r, n);
    case ">=":
      return Hi(e, r, n);
    case "<":
      return ji(e, r, n);
    case "<=":
      return Gi(e, r, n);
    default:
      throw new TypeError(`Invalid operator: ${t}`);
  }
};
var Tn = Bi;
const Fi = re, Mi = Le, { re: qe, t: Ke } = Ce, Ui = (e, t) => {
  if (e instanceof Fi)
    return e;
  if (typeof e == "number" && (e = String(e)), typeof e != "string")
    return null;
  t = t || {};
  let r = null;
  if (!t.rtl)
    r = e.match(qe[Ke.COERCE]);
  else {
    let n;
    for (; (n = qe[Ke.COERCERTL].exec(e)) && (!r || r.index + r[0].length !== e.length); )
      (!r || n.index + n[0].length !== r.index + r[0].length) && (r = n), qe[Ke.COERCERTL].lastIndex = n.index + n[1].length + n[2].length;
    qe[Ke.COERCERTL].lastIndex = -1;
  }
  return r === null ? null : Mi(`${r[2]}.${r[3] || "0"}.${r[4] || "0"}`, t);
};
var ki = Ui, yt, Lr;
function Vi() {
  return Lr || (Lr = 1, yt = function(e) {
    e.prototype[Symbol.iterator] = function* () {
      for (let t = this.head; t; t = t.next)
        yield t.value;
    };
  }), yt;
}
var Xi = k;
k.Node = _e;
k.create = k;
function k(e) {
  var t = this;
  if (t instanceof k || (t = new k()), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function")
    e.forEach(function(i) {
      t.push(i);
    });
  else if (arguments.length > 0)
    for (var r = 0, n = arguments.length; r < n; r++)
      t.push(arguments[r]);
  return t;
}
k.prototype.removeNode = function(e) {
  if (e.list !== this)
    throw new Error("removing node which does not belong to this list");
  var t = e.next, r = e.prev;
  return t && (t.prev = r), r && (r.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = r), e.list.length--, e.next = null, e.prev = null, e.list = null, t;
};
k.prototype.unshiftNode = function(e) {
  if (e !== this.head) {
    e.list && e.list.removeNode(e);
    var t = this.head;
    e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
  }
};
k.prototype.pushNode = function(e) {
  if (e !== this.tail) {
    e.list && e.list.removeNode(e);
    var t = this.tail;
    e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
  }
};
k.prototype.push = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    Ki(this, arguments[e]);
  return this.length;
};
k.prototype.unshift = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    zi(this, arguments[e]);
  return this.length;
};
k.prototype.pop = function() {
  if (this.tail) {
    var e = this.tail.value;
    return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
  }
};
k.prototype.shift = function() {
  if (this.head) {
    var e = this.head.value;
    return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
  }
};
k.prototype.forEach = function(e, t) {
  t = t || this;
  for (var r = this.head, n = 0; r !== null; n++)
    e.call(t, r.value, n, this), r = r.next;
};
k.prototype.forEachReverse = function(e, t) {
  t = t || this;
  for (var r = this.tail, n = this.length - 1; r !== null; n--)
    e.call(t, r.value, n, this), r = r.prev;
};
k.prototype.get = function(e) {
  for (var t = 0, r = this.head; r !== null && t < e; t++)
    r = r.next;
  if (t === e && r !== null)
    return r.value;
};
k.prototype.getReverse = function(e) {
  for (var t = 0, r = this.tail; r !== null && t < e; t++)
    r = r.prev;
  if (t === e && r !== null)
    return r.value;
};
k.prototype.map = function(e, t) {
  t = t || this;
  for (var r = new k(), n = this.head; n !== null; )
    r.push(e.call(t, n.value, this)), n = n.next;
  return r;
};
k.prototype.mapReverse = function(e, t) {
  t = t || this;
  for (var r = new k(), n = this.tail; n !== null; )
    r.push(e.call(t, n.value, this)), n = n.prev;
  return r;
};
k.prototype.reduce = function(e, t) {
  var r, n = this.head;
  if (arguments.length > 1)
    r = t;
  else if (this.head)
    n = this.head.next, r = this.head.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var i = 0; n !== null; i++)
    r = e(r, n.value, i), n = n.next;
  return r;
};
k.prototype.reduceReverse = function(e, t) {
  var r, n = this.tail;
  if (arguments.length > 1)
    r = t;
  else if (this.tail)
    n = this.tail.prev, r = this.tail.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var i = this.length - 1; n !== null; i--)
    r = e(r, n.value, i), n = n.prev;
  return r;
};
k.prototype.toArray = function() {
  for (var e = new Array(this.length), t = 0, r = this.head; r !== null; t++)
    e[t] = r.value, r = r.next;
  return e;
};
k.prototype.toArrayReverse = function() {
  for (var e = new Array(this.length), t = 0, r = this.tail; r !== null; t++)
    e[t] = r.value, r = r.prev;
  return e;
};
k.prototype.slice = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var r = new k();
  if (t < e || t < 0)
    return r;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var n = 0, i = this.head; i !== null && n < e; n++)
    i = i.next;
  for (; i !== null && n < t; n++, i = i.next)
    r.push(i.value);
  return r;
};
k.prototype.sliceReverse = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var r = new k();
  if (t < e || t < 0)
    return r;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var n = this.length, i = this.tail; i !== null && n > t; n--)
    i = i.prev;
  for (; i !== null && n > e; n--, i = i.prev)
    r.push(i.value);
  return r;
};
k.prototype.splice = function(e, t, ...r) {
  e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
  for (var n = 0, i = this.head; i !== null && n < e; n++)
    i = i.next;
  for (var s = [], n = 0; i && n < t; n++)
    s.push(i.value), i = this.removeNode(i);
  i === null && (i = this.tail), i !== this.head && i !== this.tail && (i = i.prev);
  for (var n = 0; n < r.length; n++)
    i = qi(this, i, r[n]);
  return s;
};
k.prototype.reverse = function() {
  for (var e = this.head, t = this.tail, r = e; r !== null; r = r.prev) {
    var n = r.prev;
    r.prev = r.next, r.next = n;
  }
  return this.head = t, this.tail = e, this;
};
function qi(e, t, r) {
  var n = t === e.head ? new _e(r, null, t, e) : new _e(r, t, t.next, e);
  return n.next === null && (e.tail = n), n.prev === null && (e.head = n), e.length++, n;
}
function Ki(e, t) {
  e.tail = new _e(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
}
function zi(e, t) {
  e.head = new _e(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
}
function _e(e, t, r, n) {
  if (!(this instanceof _e))
    return new _e(e, t, r, n);
  this.list = n, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null;
}
try {
  Vi()(k);
} catch {
}
const Wi = Xi, Re = Symbol("max"), he = Symbol("length"), be = Symbol("lengthCalculator"), je = Symbol("allowStale"), Ae = Symbol("maxAge"), pe = Symbol("dispose"), Pr = Symbol("noDisposeOnSet"), J = Symbol("lruList"), ie = Symbol("cache"), In = Symbol("updateAgeOnGet"), Rt = () => 1;
class Yi {
  constructor(t) {
    if (typeof t == "number" && (t = { max: t }), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[Re] = t.max || 1 / 0;
    const r = t.length || Rt;
    if (this[be] = typeof r != "function" ? Rt : r, this[je] = t.stale || !1, t.maxAge && typeof t.maxAge != "number")
      throw new TypeError("maxAge must be a number");
    this[Ae] = t.maxAge || 0, this[pe] = t.dispose, this[Pr] = t.noDisposeOnSet || !1, this[In] = t.updateAgeOnGet || !1, this.reset();
  }
  // resize the cache when the max changes.
  set max(t) {
    if (typeof t != "number" || t < 0)
      throw new TypeError("max must be a non-negative number");
    this[Re] = t || 1 / 0, Pe(this);
  }
  get max() {
    return this[Re];
  }
  set allowStale(t) {
    this[je] = !!t;
  }
  get allowStale() {
    return this[je];
  }
  set maxAge(t) {
    if (typeof t != "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[Ae] = t, Pe(this);
  }
  get maxAge() {
    return this[Ae];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(t) {
    typeof t != "function" && (t = Rt), t !== this[be] && (this[be] = t, this[he] = 0, this[J].forEach((r) => {
      r.length = this[be](r.value, r.key), this[he] += r.length;
    })), Pe(this);
  }
  get lengthCalculator() {
    return this[be];
  }
  get length() {
    return this[he];
  }
  get itemCount() {
    return this[J].length;
  }
  rforEach(t, r) {
    r = r || this;
    for (let n = this[J].tail; n !== null; ) {
      const i = n.prev;
      Dr(this, t, n, r), n = i;
    }
  }
  forEach(t, r) {
    r = r || this;
    for (let n = this[J].head; n !== null; ) {
      const i = n.next;
      Dr(this, t, n, r), n = i;
    }
  }
  keys() {
    return this[J].toArray().map((t) => t.key);
  }
  values() {
    return this[J].toArray().map((t) => t.value);
  }
  reset() {
    this[pe] && this[J] && this[J].length && this[J].forEach((t) => this[pe](t.key, t.value)), this[ie] = /* @__PURE__ */ new Map(), this[J] = new Wi(), this[he] = 0;
  }
  dump() {
    return this[J].map((t) => Ze(this, t) ? !1 : {
      k: t.key,
      v: t.value,
      e: t.now + (t.maxAge || 0)
    }).toArray().filter((t) => t);
  }
  dumpLru() {
    return this[J];
  }
  set(t, r, n) {
    if (n = n || this[Ae], n && typeof n != "number")
      throw new TypeError("maxAge must be a number");
    const i = n ? Date.now() : 0, s = this[be](r, t);
    if (this[ie].has(t)) {
      if (s > this[Re])
        return Ne(this, this[ie].get(t)), !1;
      const l = this[ie].get(t).value;
      return this[pe] && (this[Pr] || this[pe](t, l.value)), l.now = i, l.maxAge = n, l.value = r, this[he] += s - l.length, l.length = s, this.get(t), Pe(this), !0;
    }
    const o = new Zi(t, r, s, i, n);
    return o.length > this[Re] ? (this[pe] && this[pe](t, r), !1) : (this[he] += o.length, this[J].unshift(o), this[ie].set(t, this[J].head), Pe(this), !0);
  }
  has(t) {
    if (!this[ie].has(t)) return !1;
    const r = this[ie].get(t).value;
    return !Ze(this, r);
  }
  get(t) {
    return At(this, t, !0);
  }
  peek(t) {
    return At(this, t, !1);
  }
  pop() {
    const t = this[J].tail;
    return t ? (Ne(this, t), t.value) : null;
  }
  del(t) {
    Ne(this, this[ie].get(t));
  }
  load(t) {
    this.reset();
    const r = Date.now();
    for (let n = t.length - 1; n >= 0; n--) {
      const i = t[n], s = i.e || 0;
      if (s === 0)
        this.set(i.k, i.v);
      else {
        const o = s - r;
        o > 0 && this.set(i.k, i.v, o);
      }
    }
  }
  prune() {
    this[ie].forEach((t, r) => At(this, r, !1));
  }
}
const At = (e, t, r) => {
  const n = e[ie].get(t);
  if (n) {
    const i = n.value;
    if (Ze(e, i)) {
      if (Ne(e, n), !e[je])
        return;
    } else
      r && (e[In] && (n.value.now = Date.now()), e[J].unshiftNode(n));
    return i.value;
  }
}, Ze = (e, t) => {
  if (!t || !t.maxAge && !e[Ae])
    return !1;
  const r = Date.now() - t.now;
  return t.maxAge ? r > t.maxAge : e[Ae] && r > e[Ae];
}, Pe = (e) => {
  if (e[he] > e[Re])
    for (let t = e[J].tail; e[he] > e[Re] && t !== null; ) {
      const r = t.prev;
      Ne(e, t), t = r;
    }
}, Ne = (e, t) => {
  if (t) {
    const r = t.value;
    e[pe] && e[pe](r.key, r.value), e[he] -= r.length, e[ie].delete(r.key), e[J].removeNode(t);
  }
};
class Zi {
  constructor(t, r, n, i, s) {
    this.key = t, this.value = r, this.length = n, this.now = i, this.maxAge = s || 0;
  }
}
const Dr = (e, t, r, n) => {
  let i = r.value;
  Ze(e, i) && (Ne(e, r), e[je] || (i = void 0)), i && t.call(n, i.value, i.key, e);
};
var Qi = Yi, wt, Hr;
function ae() {
  if (Hr) return wt;
  Hr = 1;
  class e {
    constructor($, S) {
      if (S = n(S), $ instanceof e)
        return $.loose === !!S.loose && $.includePrerelease === !!S.includePrerelease ? $ : new e($.raw, S);
      if ($ instanceof i)
        return this.raw = $.value, this.set = [[$]], this.format(), this;
      if (this.options = S, this.loose = !!S.loose, this.includePrerelease = !!S.includePrerelease, this.raw = $, this.set = $.split("||").map((f) => this.parseRange(f.trim())).filter((f) => f.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${$}`);
      if (this.set.length > 1) {
        const f = this.set[0];
        if (this.set = this.set.filter((p) => !g(p[0])), this.set.length === 0)
          this.set = [f];
        else if (this.set.length > 1) {
          for (const p of this.set)
            if (p.length === 1 && h(p[0])) {
              this.set = [p];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map(($) => $.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange($) {
      $ = $.trim();
      const f = `parseRange:${Object.keys(this.options).join(",")}:${$}`, p = r.get(f);
      if (p)
        return p;
      const m = this.options.loose, v = m ? a[l.HYPHENRANGELOOSE] : a[l.HYPHENRANGE];
      $ = $.replace(v, L(this.options.includePrerelease)), s("hyphen replace", $), $ = $.replace(a[l.COMPARATORTRIM], u), s("comparator trim", $), $ = $.replace(a[l.TILDETRIM], c), $ = $.replace(a[l.CARETTRIM], d), $ = $.split(/\s+/).join(" ");
      let A = $.split(" ").map((X) => N(X, this.options)).join(" ").split(/\s+/).map((X) => P(X, this.options));
      m && (A = A.filter((X) => (s("loose invalid filter", X, this.options), !!X.match(a[l.COMPARATORLOOSE])))), s("range list", A);
      const x = /* @__PURE__ */ new Map(), j = A.map((X) => new i(X, this.options));
      for (const X of j) {
        if (g(X))
          return [X];
        x.set(X.value, X);
      }
      x.size > 1 && x.has("") && x.delete("");
      const q = [...x.values()];
      return r.set(f, q), q;
    }
    intersects($, S) {
      if (!($ instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((f) => b(f, S) && $.set.some((p) => b(p, S) && f.every((m) => p.every((v) => m.intersects(v, S)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test($) {
      if (!$)
        return !1;
      if (typeof $ == "string")
        try {
          $ = new o($, this.options);
        } catch {
          return !1;
        }
      for (let S = 0; S < this.set.length; S++)
        if (E(this.set[S], $, this.options))
          return !0;
      return !1;
    }
  }
  wt = e;
  const t = Qi, r = new t({ max: 1e3 }), n = at, i = ct(), s = ot, o = re, {
    re: a,
    t: l,
    comparatorTrimReplace: u,
    tildeTrimReplace: c,
    caretTrimReplace: d
  } = Ce, g = (w) => w.value === "<0.0.0-0", h = (w) => w.value === "", b = (w, $) => {
    let S = !0;
    const f = w.slice();
    let p = f.pop();
    for (; S && f.length; )
      S = f.every((m) => p.intersects(m, $)), p = f.pop();
    return S;
  }, N = (w, $) => (s("comp", w, $), w = y(w, $), s("caret", w), w = I(w, $), s("tildes", w), w = D(w, $), s("xrange", w), w = H(w, $), s("stars", w), w), R = (w) => !w || w.toLowerCase() === "x" || w === "*", I = (w, $) => w.trim().split(/\s+/).map((S) => C(S, $)).join(" "), C = (w, $) => {
    const S = $.loose ? a[l.TILDELOOSE] : a[l.TILDE];
    return w.replace(S, (f, p, m, v, A) => {
      s("tilde", w, f, p, m, v, A);
      let x;
      return R(p) ? x = "" : R(m) ? x = `>=${p}.0.0 <${+p + 1}.0.0-0` : R(v) ? x = `>=${p}.${m}.0 <${p}.${+m + 1}.0-0` : A ? (s("replaceTilde pr", A), x = `>=${p}.${m}.${v}-${A} <${p}.${+m + 1}.0-0`) : x = `>=${p}.${m}.${v} <${p}.${+m + 1}.0-0`, s("tilde return", x), x;
    });
  }, y = (w, $) => w.trim().split(/\s+/).map((S) => T(S, $)).join(" "), T = (w, $) => {
    s("caret", w, $);
    const S = $.loose ? a[l.CARETLOOSE] : a[l.CARET], f = $.includePrerelease ? "-0" : "";
    return w.replace(S, (p, m, v, A, x) => {
      s("caret", w, p, m, v, A, x);
      let j;
      return R(m) ? j = "" : R(v) ? j = `>=${m}.0.0${f} <${+m + 1}.0.0-0` : R(A) ? m === "0" ? j = `>=${m}.${v}.0${f} <${m}.${+v + 1}.0-0` : j = `>=${m}.${v}.0${f} <${+m + 1}.0.0-0` : x ? (s("replaceCaret pr", x), m === "0" ? v === "0" ? j = `>=${m}.${v}.${A}-${x} <${m}.${v}.${+A + 1}-0` : j = `>=${m}.${v}.${A}-${x} <${m}.${+v + 1}.0-0` : j = `>=${m}.${v}.${A}-${x} <${+m + 1}.0.0-0`) : (s("no pr"), m === "0" ? v === "0" ? j = `>=${m}.${v}.${A}${f} <${m}.${v}.${+A + 1}-0` : j = `>=${m}.${v}.${A}${f} <${m}.${+v + 1}.0-0` : j = `>=${m}.${v}.${A} <${+m + 1}.0.0-0`), s("caret return", j), j;
    });
  }, D = (w, $) => (s("replaceXRanges", w, $), w.split(/\s+/).map((S) => U(S, $)).join(" ")), U = (w, $) => {
    w = w.trim();
    const S = $.loose ? a[l.XRANGELOOSE] : a[l.XRANGE];
    return w.replace(S, (f, p, m, v, A, x) => {
      s("xRange", w, f, p, m, v, A, x);
      const j = R(m), q = j || R(v), X = q || R(A), Z = X;
      return p === "=" && Z && (p = ""), x = $.includePrerelease ? "-0" : "", j ? p === ">" || p === "<" ? f = "<0.0.0-0" : f = "*" : p && Z ? (q && (v = 0), A = 0, p === ">" ? (p = ">=", q ? (m = +m + 1, v = 0, A = 0) : (v = +v + 1, A = 0)) : p === "<=" && (p = "<", q ? m = +m + 1 : v = +v + 1), p === "<" && (x = "-0"), f = `${p + m}.${v}.${A}${x}`) : q ? f = `>=${m}.0.0${x} <${+m + 1}.0.0-0` : X && (f = `>=${m}.${v}.0${x} <${m}.${+v + 1}.0-0`), s("xRange return", f), f;
    });
  }, H = (w, $) => (s("replaceStars", w, $), w.trim().replace(a[l.STAR], "")), P = (w, $) => (s("replaceGTE0", w, $), w.trim().replace(a[$.includePrerelease ? l.GTE0PRE : l.GTE0], "")), L = (w) => ($, S, f, p, m, v, A, x, j, q, X, Z, Y) => (R(f) ? S = "" : R(p) ? S = `>=${f}.0.0${w ? "-0" : ""}` : R(m) ? S = `>=${f}.${p}.0${w ? "-0" : ""}` : v ? S = `>=${S}` : S = `>=${S}${w ? "-0" : ""}`, R(j) ? x = "" : R(q) ? x = `<${+j + 1}.0.0-0` : R(X) ? x = `<${j}.${+q + 1}.0-0` : Z ? x = `<=${j}.${q}.${X}-${Z}` : w ? x = `<${j}.${q}.${+X + 1}-0` : x = `<=${x}`, `${S} ${x}`.trim()), E = (w, $, S) => {
    for (let f = 0; f < w.length; f++)
      if (!w[f].test($))
        return !1;
    if ($.prerelease.length && !S.includePrerelease) {
      for (let f = 0; f < w.length; f++)
        if (s(w[f].semver), w[f].semver !== i.ANY && w[f].semver.prerelease.length > 0) {
          const p = w[f].semver;
          if (p.major === $.major && p.minor === $.minor && p.patch === $.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return wt;
}
var _t, jr;
function ct() {
  if (jr) return _t;
  jr = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(c, d) {
      if (d = r(d), c instanceof t) {
        if (c.loose === !!d.loose)
          return c;
        c = c.value;
      }
      o("comparator", c, d), this.options = d, this.loose = !!d.loose, this.parse(c), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
    }
    parse(c) {
      const d = this.options.loose ? n[i.COMPARATORLOOSE] : n[i.COMPARATOR], g = c.match(d);
      if (!g)
        throw new TypeError(`Invalid comparator: ${c}`);
      this.operator = g[1] !== void 0 ? g[1] : "", this.operator === "=" && (this.operator = ""), g[2] ? this.semver = new a(g[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(c) {
      if (o("Comparator.test", c, this.options.loose), this.semver === e || c === e)
        return !0;
      if (typeof c == "string")
        try {
          c = new a(c, this.options);
        } catch {
          return !1;
        }
      return s(c, this.operator, this.semver, this.options);
    }
    intersects(c, d) {
      if (!(c instanceof t))
        throw new TypeError("a Comparator is required");
      if ((!d || typeof d != "object") && (d = {
        loose: !!d,
        includePrerelease: !1
      }), this.operator === "")
        return this.value === "" ? !0 : new l(c.value, d).test(this.value);
      if (c.operator === "")
        return c.value === "" ? !0 : new l(this.value, d).test(c.semver);
      const g = (this.operator === ">=" || this.operator === ">") && (c.operator === ">=" || c.operator === ">"), h = (this.operator === "<=" || this.operator === "<") && (c.operator === "<=" || c.operator === "<"), b = this.semver.version === c.semver.version, N = (this.operator === ">=" || this.operator === "<=") && (c.operator === ">=" || c.operator === "<="), R = s(this.semver, "<", c.semver, d) && (this.operator === ">=" || this.operator === ">") && (c.operator === "<=" || c.operator === "<"), I = s(this.semver, ">", c.semver, d) && (this.operator === "<=" || this.operator === "<") && (c.operator === ">=" || c.operator === ">");
      return g || h || b && N || R || I;
    }
  }
  _t = t;
  const r = at, { re: n, t: i } = Ce, s = Tn, o = ot, a = re, l = ae();
  return _t;
}
const Ji = ae(), eo = (e, t, r) => {
  try {
    t = new Ji(t, r);
  } catch {
    return !1;
  }
  return t.test(e);
};
var ut = eo;
const to = ae(), ro = (e, t) => new to(e, t).set.map((r) => r.map((n) => n.value).join(" ").trim().split(" "));
var no = ro;
const so = re, io = ae(), oo = (e, t, r) => {
  let n = null, i = null, s = null;
  try {
    s = new io(t, r);
  } catch {
    return null;
  }
  return e.forEach((o) => {
    s.test(o) && (!n || i.compare(o) === -1) && (n = o, i = new so(n, r));
  }), n;
};
var ao = oo;
const lo = re, co = ae(), uo = (e, t, r) => {
  let n = null, i = null, s = null;
  try {
    s = new co(t, r);
  } catch {
    return null;
  }
  return e.forEach((o) => {
    s.test(o) && (!n || i.compare(o) === 1) && (n = o, i = new lo(n, r));
  }), n;
};
var fo = uo;
const St = re, po = ae(), Gr = lt, ho = (e, t) => {
  e = new po(e, t);
  let r = new St("0.0.0");
  if (e.test(r) || (r = new St("0.0.0-0"), e.test(r)))
    return r;
  r = null;
  for (let n = 0; n < e.set.length; ++n) {
    const i = e.set[n];
    let s = null;
    i.forEach((o) => {
      const a = new St(o.semver.version);
      switch (o.operator) {
        case ">":
          a.prerelease.length === 0 ? a.patch++ : a.prerelease.push(0), a.raw = a.format();
        case "":
        case ">=":
          (!s || Gr(a, s)) && (s = a);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${o.operator}`);
      }
    }), s && (!r || Gr(r, s)) && (r = s);
  }
  return r && e.test(r) ? r : null;
};
var go = ho;
const Eo = ae(), mo = (e, t) => {
  try {
    return new Eo(e, t).range || "*";
  } catch {
    return null;
  }
};
var $o = mo;
const vo = re, xn = ct(), { ANY: yo } = xn, Ro = ae(), Ao = ut, Br = lt, Fr = Kt, wo = Wt, _o = zt, So = (e, t, r, n) => {
  e = new vo(e, n), t = new Ro(t, n);
  let i, s, o, a, l;
  switch (r) {
    case ">":
      i = Br, s = wo, o = Fr, a = ">", l = ">=";
      break;
    case "<":
      i = Fr, s = _o, o = Br, a = "<", l = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (Ao(e, t, n))
    return !1;
  for (let u = 0; u < t.set.length; ++u) {
    const c = t.set[u];
    let d = null, g = null;
    if (c.forEach((h) => {
      h.semver === yo && (h = new xn(">=0.0.0")), d = d || h, g = g || h, i(h.semver, d.semver, n) ? d = h : o(h.semver, g.semver, n) && (g = h);
    }), d.operator === a || d.operator === l || (!g.operator || g.operator === a) && s(e, g.semver))
      return !1;
    if (g.operator === l && o(e, g.semver))
      return !1;
  }
  return !0;
};
var Yt = So;
const bo = Yt, Oo = (e, t, r) => bo(e, t, ">", r);
var To = Oo;
const Io = Yt, xo = (e, t, r) => Io(e, t, "<", r);
var No = xo;
const Mr = ae(), Co = (e, t, r) => (e = new Mr(e, r), t = new Mr(t, r), e.intersects(t));
var Lo = Co;
const Po = ut, Do = oe;
var Ho = (e, t, r) => {
  const n = [];
  let i = null, s = null;
  const o = e.sort((c, d) => Do(c, d, r));
  for (const c of o)
    Po(c, t, r) ? (s = c, i || (i = c)) : (s && n.push([i, s]), s = null, i = null);
  i && n.push([i, null]);
  const a = [];
  for (const [c, d] of n)
    c === d ? a.push(c) : !d && c === o[0] ? a.push("*") : d ? c === o[0] ? a.push(`<=${d}`) : a.push(`${c} - ${d}`) : a.push(`>=${c}`);
  const l = a.join(" || "), u = typeof t.raw == "string" ? t.raw : String(t);
  return l.length < u.length ? l : t;
};
const Ur = ae(), Ye = ct(), { ANY: bt } = Ye, De = ut, Zt = oe, jo = (e, t, r = {}) => {
  if (e === t)
    return !0;
  e = new Ur(e, r), t = new Ur(t, r);
  let n = !1;
  e: for (const i of e.set) {
    for (const s of t.set) {
      const o = Go(i, s, r);
      if (n = n || o !== null, o)
        continue e;
    }
    if (n)
      return !1;
  }
  return !0;
}, Go = (e, t, r) => {
  if (e === t)
    return !0;
  if (e.length === 1 && e[0].semver === bt) {
    if (t.length === 1 && t[0].semver === bt)
      return !0;
    r.includePrerelease ? e = [new Ye(">=0.0.0-0")] : e = [new Ye(">=0.0.0")];
  }
  if (t.length === 1 && t[0].semver === bt) {
    if (r.includePrerelease)
      return !0;
    t = [new Ye(">=0.0.0")];
  }
  const n = /* @__PURE__ */ new Set();
  let i, s;
  for (const h of e)
    h.operator === ">" || h.operator === ">=" ? i = kr(i, h, r) : h.operator === "<" || h.operator === "<=" ? s = Vr(s, h, r) : n.add(h.semver);
  if (n.size > 1)
    return null;
  let o;
  if (i && s) {
    if (o = Zt(i.semver, s.semver, r), o > 0)
      return null;
    if (o === 0 && (i.operator !== ">=" || s.operator !== "<="))
      return null;
  }
  for (const h of n) {
    if (i && !De(h, String(i), r) || s && !De(h, String(s), r))
      return null;
    for (const b of t)
      if (!De(h, String(b), r))
        return !1;
    return !0;
  }
  let a, l, u, c, d = s && !r.includePrerelease && s.semver.prerelease.length ? s.semver : !1, g = i && !r.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
  d && d.prerelease.length === 1 && s.operator === "<" && d.prerelease[0] === 0 && (d = !1);
  for (const h of t) {
    if (c = c || h.operator === ">" || h.operator === ">=", u = u || h.operator === "<" || h.operator === "<=", i) {
      if (g && h.semver.prerelease && h.semver.prerelease.length && h.semver.major === g.major && h.semver.minor === g.minor && h.semver.patch === g.patch && (g = !1), h.operator === ">" || h.operator === ">=") {
        if (a = kr(i, h, r), a === h && a !== i)
          return !1;
      } else if (i.operator === ">=" && !De(i.semver, String(h), r))
        return !1;
    }
    if (s) {
      if (d && h.semver.prerelease && h.semver.prerelease.length && h.semver.major === d.major && h.semver.minor === d.minor && h.semver.patch === d.patch && (d = !1), h.operator === "<" || h.operator === "<=") {
        if (l = Vr(s, h, r), l === h && l !== s)
          return !1;
      } else if (s.operator === "<=" && !De(s.semver, String(h), r))
        return !1;
    }
    if (!h.operator && (s || i) && o !== 0)
      return !1;
  }
  return !(i && u && !s && o !== 0 || s && c && !i && o !== 0 || g || d);
}, kr = (e, t, r) => {
  if (!e)
    return t;
  const n = Zt(e.semver, t.semver, r);
  return n > 0 ? e : n < 0 || t.operator === ">" && e.operator === ">=" ? t : e;
}, Vr = (e, t, r) => {
  if (!e)
    return t;
  const n = Zt(e.semver, t.semver, r);
  return n < 0 ? e : n > 0 || t.operator === "<" && e.operator === "<=" ? t : e;
};
var Bo = jo;
const Ot = Ce, Fo = it, Mo = re, Xr = bn, Uo = Le, ko = Fs, Vo = ks, Xo = Xs, qo = Zs, Ko = ei, zo = ni, Wo = oi, Yo = ci, Zo = oe, Qo = pi, Jo = gi, ea = qt, ta = vi, ra = Ai, na = lt, sa = Kt, ia = Xt, oa = On, aa = zt, la = Wt, ca = Tn, ua = ki, fa = ct(), pa = ae(), ha = ut, da = no, ga = ao, Ea = fo, ma = go, $a = $o, va = Yt, ya = To, Ra = No, Aa = Lo, wa = Ho, _a = Bo;
var ee = {
  parse: Uo,
  valid: ko,
  clean: Vo,
  inc: Xo,
  diff: qo,
  major: Ko,
  minor: zo,
  patch: Wo,
  prerelease: Yo,
  compare: Zo,
  rcompare: Qo,
  compareLoose: Jo,
  compareBuild: ea,
  sort: ta,
  rsort: ra,
  gt: na,
  lt: sa,
  eq: ia,
  neq: oa,
  gte: aa,
  lte: la,
  cmp: ca,
  coerce: ua,
  Comparator: fa,
  Range: pa,
  satisfies: ha,
  toComparators: da,
  maxSatisfying: ga,
  minSatisfying: Ea,
  minVersion: ma,
  validRange: $a,
  outside: va,
  gtr: ya,
  ltr: Ra,
  intersects: Aa,
  simplifyRange: wa,
  subset: _a,
  SemVer: Mo,
  re: Ot.re,
  src: Ot.src,
  tokens: Ot.t,
  SEMVER_SPEC_VERSION: Fo.SEMVER_SPEC_VERSION,
  compareIdentifiers: Xr.compareIdentifiers,
  rcompareIdentifiers: Xr.rcompareIdentifiers
};
const Sa = [
  [1e3, 6e4, "sec"],
  [6e4, 36e5, "min"],
  [36e5, 864e5, "hour"],
  [864e5, 6048e5, "day"],
  [6048e5, 2628e6, "week"],
  [2628e6, 31536e6, "month"],
  [31536e6, 1 / 0, "year"]
], ba = {
  "1 day ago": "yesterday",
  "1 week ago": "last week",
  "1 month ago": "last month",
  "1 year ago": "last year",
  "in 1 day": "tomorrow",
  "in 1 week": "next week",
  "in 1 month": "next month",
  "in 1 year": "next year"
}, Oa = {
  sec: "second",
  min: "minute"
};
function qr(e) {
  return e instanceof Date ? e.getTime() : typeof e == "string" ? Date.parse(e) : e;
}
function Kr(e, { now: t, noAffix: r = !1, times: n = Sa, nowThreshold: i = 2e3, nowString: s = "now", unknownString: o = "", aliases: a = !1, aliasesMap: l = ba, longUnits: u = !1 } = {}) {
  const c = qr(e);
  if (t = t !== void 0 ? qr(t) : Date.now(), Number.isNaN(c))
    return o || String(e);
  let d = !1, g = t - c;
  if (g < 0 && (d = !0, g = Math.abs(g)), g < i)
    return s;
  let h, b;
  for (let R = 0, I = n.length; R < I; R++) {
    const C = n[R];
    if (!(g >= C[1])) {
      h = Math.floor(g / C[0]), b = (u && Oa[C[2]] || C[2]) + (h > 1 ? "s" : "");
      break;
    }
  }
  const N = `${d && !r ? "in " : ""}${h} ${b}${!d && !r ? " ago" : ""}`;
  return a ? l[N] ?? N : N;
}
function se(e, t = globalThis.Deno ? globalThis.Deno.args : Ut.argv) {
  const r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t.indexOf(r + e), i = t.indexOf("--");
  return n !== -1 && (i === -1 || n < i);
}
const { env: z } = Ut;
let Qe;
se("no-color") || se("no-colors") || se("color=false") || se("color=never") ? Qe = 0 : (se("color") || se("colors") || se("color=true") || se("color=always")) && (Qe = 1);
function Ta() {
  if ("FORCE_COLOR" in z)
    return z.FORCE_COLOR === "true" ? 1 : z.FORCE_COLOR === "false" ? 0 : z.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(z.FORCE_COLOR, 10), 3);
}
function Ia(e) {
  return e === 0 ? !1 : {
    level: e,
    hasBasic: !0,
    has256: e >= 2,
    has16m: e >= 3
  };
}
function xa(e, { streamIsTTY: t, sniffFlags: r = !0 } = {}) {
  const n = Ta();
  n !== void 0 && (Qe = n);
  const i = r ? Qe : n;
  if (i === 0)
    return 0;
  if (r) {
    if (se("color=16m") || se("color=full") || se("color=truecolor"))
      return 3;
    if (se("color=256"))
      return 2;
  }
  if ("TF_BUILD" in z && "AGENT_NAME" in z)
    return 1;
  if (e && !t && i === void 0)
    return 0;
  const s = i || 0;
  if (z.TERM === "dumb")
    return s;
  if (Ut.platform === "win32") {
    const o = rs.release().split(".");
    return Number(o[0]) >= 10 && Number(o[2]) >= 10586 ? Number(o[2]) >= 14931 ? 3 : 2 : 1;
  }
  if ("CI" in z)
    return "GITHUB_ACTIONS" in z || "GITEA_ACTIONS" in z ? 3 : ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((o) => o in z) || z.CI_NAME === "codeship" ? 1 : s;
  if ("TEAMCITY_VERSION" in z)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(z.TEAMCITY_VERSION) ? 1 : 0;
  if (z.COLORTERM === "truecolor" || z.TERM === "xterm-kitty")
    return 3;
  if ("TERM_PROGRAM" in z) {
    const o = Number.parseInt((z.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (z.TERM_PROGRAM) {
      case "iTerm.app":
        return o >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(z.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(z.TERM) || "COLORTERM" in z ? 1 : s;
}
function zr(e, t = {}) {
  const r = xa(e, {
    streamIsTTY: e && e.isTTY,
    ...t
  });
  return Ia(r);
}
const Na = {
  stdout: zr({ isTTY: ur.isatty(1) }),
  stderr: zr({ isTTY: ur.isatty(2) })
};
let Nn = !0;
function Ca() {
  Nn = !1;
}
function Qt(e, t, r) {
  const n = e.join(" ");
  return Nn ? `\x1B[${t}m${n}\x1B[${r}m` : n;
}
const Jt = (...e) => Qt(e, 31, 39), er = (...e) => Qt(e, 32, 39), La = (...e) => Qt(e, 35, 39);
class Pa extends Error {
  constructor(t) {
    super(), this.name = "AbortError", this.message = t;
  }
}
const Wr = (e) => globalThis.DOMException === void 0 ? new Pa(e) : new DOMException(e), Yr = (e) => {
  const t = e.reason === void 0 ? Wr("This operation was aborted.") : e.reason;
  return t instanceof Error ? t : Wr(t);
};
async function Da(e, t, {
  concurrency: r = Number.POSITIVE_INFINITY,
  stopOnError: n = !0,
  signal: i
} = {}) {
  return new Promise((s, o) => {
    if (e[Symbol.iterator] === void 0 && e[Symbol.asyncIterator] === void 0)
      throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof e})`);
    if (typeof t != "function")
      throw new TypeError("Mapper function is required");
    if (!((Number.isSafeInteger(r) || r === Number.POSITIVE_INFINITY) && r >= 1))
      throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${r}\` (${typeof r})`);
    const a = [], l = [], u = /* @__PURE__ */ new Map();
    let c = !1, d = !1, g = !1, h = 0, b = 0;
    const N = e[Symbol.iterator] === void 0 ? e[Symbol.asyncIterator]() : e[Symbol.iterator](), R = (C) => {
      c = !0, d = !0, o(C);
    };
    i && (i.aborted && R(Yr(i)), i.addEventListener("abort", () => {
      R(Yr(i));
    }));
    const I = async () => {
      if (d)
        return;
      const C = await N.next(), y = b;
      if (b++, C.done) {
        if (g = !0, h === 0 && !d) {
          if (!n && l.length > 0) {
            R(new AggregateError(l));
            return;
          }
          if (d = !0, u.size === 0) {
            s(a);
            return;
          }
          const T = [];
          for (const [D, U] of a.entries())
            u.get(D) !== Zr && T.push(U);
          s(T);
        }
        return;
      }
      h++, (async () => {
        try {
          const T = await C.value;
          if (d)
            return;
          const D = await t(T, y);
          D === Zr && u.set(y, D), a[y] = D, h--, await I();
        } catch (T) {
          if (n)
            R(T);
          else {
            l.push(T), h--;
            try {
              await I();
            } catch (D) {
              R(D);
            }
          }
        }
      })();
    };
    (async () => {
      for (let C = 0; C < r; C++) {
        try {
          await I();
        } catch (y) {
          R(y);
          break;
        }
        if (g || c)
          break;
      }
    })();
  });
}
const Zr = Symbol("skip");
async function Qr(e, t) {
  return Da(e, (r) => r(), t);
}
var Fe = {};
const ce = "\\\\/", Jr = `[^${ce}]`, de = "\\.", Ha = "\\+", ja = "\\?", ft = "\\/", Ga = "(?=.)", Cn = "[^/]", tr = `(?:${ft}|$)`, Ln = `(?:^|${ft})`, rr = `${de}{1,2}${tr}`, Ba = `(?!${de})`, Fa = `(?!${Ln}${rr})`, Ma = `(?!${de}{0,1}${tr})`, Ua = `(?!${rr})`, ka = `[^.${ft}]`, Va = `${Cn}*?`, Xa = "/", Pn = {
  DOT_LITERAL: de,
  PLUS_LITERAL: Ha,
  QMARK_LITERAL: ja,
  SLASH_LITERAL: ft,
  ONE_CHAR: Ga,
  QMARK: Cn,
  END_ANCHOR: tr,
  DOTS_SLASH: rr,
  NO_DOT: Ba,
  NO_DOTS: Fa,
  NO_DOT_SLASH: Ma,
  NO_DOTS_SLASH: Ua,
  QMARK_NO_DOT: ka,
  STAR: Va,
  START_ANCHOR: Ln,
  SEP: Xa
}, qa = {
  ...Pn,
  SLASH_LITERAL: `[${ce}]`,
  QMARK: Jr,
  STAR: `${Jr}*?`,
  DOTS_SLASH: `${de}{1,2}(?:[${ce}]|$)`,
  NO_DOT: `(?!${de})`,
  NO_DOTS: `(?!(?:^|[${ce}])${de}{1,2}(?:[${ce}]|$))`,
  NO_DOT_SLASH: `(?!${de}{0,1}(?:[${ce}]|$))`,
  NO_DOTS_SLASH: `(?!${de}{1,2}(?:[${ce}]|$))`,
  QMARK_NO_DOT: `[^.${ce}]`,
  START_ANCHOR: `(?:^|[${ce}])`,
  END_ANCHOR: `(?:[${ce}]|$)`,
  SEP: "\\"
}, Ka = {
  alnum: "a-zA-Z0-9",
  alpha: "a-zA-Z",
  ascii: "\\x00-\\x7F",
  blank: " \\t",
  cntrl: "\\x00-\\x1F\\x7F",
  digit: "0-9",
  graph: "\\x21-\\x7E",
  lower: "a-z",
  print: "\\x20-\\x7E ",
  punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
  space: " \\t\\r\\n\\v\\f",
  upper: "A-Z",
  word: "A-Za-z0-9_",
  xdigit: "A-Fa-f0-9"
};
var pt = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE: Ka,
  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    "***": "*",
    "**/**": "**",
    "**/**/**": "**"
  },
  // Digits
  CHAR_0: 48,
  /* 0 */
  CHAR_9: 57,
  /* 9 */
  // Alphabet chars.
  CHAR_UPPERCASE_A: 65,
  /* A */
  CHAR_LOWERCASE_A: 97,
  /* a */
  CHAR_UPPERCASE_Z: 90,
  /* Z */
  CHAR_LOWERCASE_Z: 122,
  /* z */
  CHAR_LEFT_PARENTHESES: 40,
  /* ( */
  CHAR_RIGHT_PARENTHESES: 41,
  /* ) */
  CHAR_ASTERISK: 42,
  /* * */
  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38,
  /* & */
  CHAR_AT: 64,
  /* @ */
  CHAR_BACKWARD_SLASH: 92,
  /* \ */
  CHAR_CARRIAGE_RETURN: 13,
  /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94,
  /* ^ */
  CHAR_COLON: 58,
  /* : */
  CHAR_COMMA: 44,
  /* , */
  CHAR_DOT: 46,
  /* . */
  CHAR_DOUBLE_QUOTE: 34,
  /* " */
  CHAR_EQUAL: 61,
  /* = */
  CHAR_EXCLAMATION_MARK: 33,
  /* ! */
  CHAR_FORM_FEED: 12,
  /* \f */
  CHAR_FORWARD_SLASH: 47,
  /* / */
  CHAR_GRAVE_ACCENT: 96,
  /* ` */
  CHAR_HASH: 35,
  /* # */
  CHAR_HYPHEN_MINUS: 45,
  /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60,
  /* < */
  CHAR_LEFT_CURLY_BRACE: 123,
  /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91,
  /* [ */
  CHAR_LINE_FEED: 10,
  /* \n */
  CHAR_NO_BREAK_SPACE: 160,
  /* \u00A0 */
  CHAR_PERCENT: 37,
  /* % */
  CHAR_PLUS: 43,
  /* + */
  CHAR_QUESTION_MARK: 63,
  /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62,
  /* > */
  CHAR_RIGHT_CURLY_BRACE: 125,
  /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93,
  /* ] */
  CHAR_SEMICOLON: 59,
  /* ; */
  CHAR_SINGLE_QUOTE: 39,
  /* ' */
  CHAR_SPACE: 32,
  /*   */
  CHAR_TAB: 9,
  /* \t */
  CHAR_UNDERSCORE: 95,
  /* _ */
  CHAR_VERTICAL_LINE: 124,
  /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
  /* \uFEFF */
  /**
   * Create EXTGLOB_CHARS
   */
  extglobChars(e) {
    return {
      "!": { type: "negate", open: "(?:(?!(?:", close: `))${e.STAR})` },
      "?": { type: "qmark", open: "(?:", close: ")?" },
      "+": { type: "plus", open: "(?:", close: ")+" },
      "*": { type: "star", open: "(?:", close: ")*" },
      "@": { type: "at", open: "(?:", close: ")" }
    };
  },
  /**
   * Create GLOB_CHARS
   */
  globChars(e) {
    return e === !0 ? qa : Pn;
  }
};
(function(e) {
  const {
    REGEX_BACKSLASH: t,
    REGEX_REMOVE_BACKSLASH: r,
    REGEX_SPECIAL_CHARS: n,
    REGEX_SPECIAL_CHARS_GLOBAL: i
  } = pt;
  e.isObject = (s) => s !== null && typeof s == "object" && !Array.isArray(s), e.hasRegexChars = (s) => n.test(s), e.isRegexChar = (s) => s.length === 1 && e.hasRegexChars(s), e.escapeRegex = (s) => s.replace(i, "\\$1"), e.toPosixSlashes = (s) => s.replace(t, "/"), e.isWindows = () => {
    if (typeof navigator < "u" && navigator.platform) {
      const s = navigator.platform.toLowerCase();
      return s === "win32" || s === "windows";
    }
    return typeof process < "u" && process.platform ? process.platform === "win32" : !1;
  }, e.removeBackslashes = (s) => s.replace(r, (o) => o === "\\" ? "" : o), e.escapeLast = (s, o, a) => {
    const l = s.lastIndexOf(o, a);
    return l === -1 ? s : s[l - 1] === "\\" ? e.escapeLast(s, o, l - 1) : `${s.slice(0, l)}\\${s.slice(l)}`;
  }, e.removePrefix = (s, o = {}) => {
    let a = s;
    return a.startsWith("./") && (a = a.slice(2), o.prefix = "./"), a;
  }, e.wrapOutput = (s, o = {}, a = {}) => {
    const l = a.contains ? "" : "^", u = a.contains ? "" : "$";
    let c = `${l}(?:${s})${u}`;
    return o.negated === !0 && (c = `(?:^(?!${c}).*$)`), c;
  }, e.basename = (s, { windows: o } = {}) => {
    const a = s.split(o ? /[\\/]/ : "/"), l = a[a.length - 1];
    return l === "" ? a[a.length - 2] : l;
  };
})(Fe);
const en = Fe, {
  CHAR_ASTERISK: Tt,
  /* * */
  CHAR_AT: za,
  /* @ */
  CHAR_BACKWARD_SLASH: He,
  /* \ */
  CHAR_COMMA: Wa,
  /* , */
  CHAR_DOT: It,
  /* . */
  CHAR_EXCLAMATION_MARK: xt,
  /* ! */
  CHAR_FORWARD_SLASH: Dn,
  /* / */
  CHAR_LEFT_CURLY_BRACE: Nt,
  /* { */
  CHAR_LEFT_PARENTHESES: Ct,
  /* ( */
  CHAR_LEFT_SQUARE_BRACKET: Ya,
  /* [ */
  CHAR_PLUS: Za,
  /* + */
  CHAR_QUESTION_MARK: tn,
  /* ? */
  CHAR_RIGHT_CURLY_BRACE: Qa,
  /* } */
  CHAR_RIGHT_PARENTHESES: rn,
  /* ) */
  CHAR_RIGHT_SQUARE_BRACKET: Ja
  /* ] */
} = pt, nn = (e) => e === Dn || e === He, sn = (e) => {
  e.isPrefix !== !0 && (e.depth = e.isGlobstar ? 1 / 0 : 1);
}, el = (e, t) => {
  const r = t || {}, n = e.length - 1, i = r.parts === !0 || r.scanToEnd === !0, s = [], o = [], a = [];
  let l = e, u = -1, c = 0, d = 0, g = !1, h = !1, b = !1, N = !1, R = !1, I = !1, C = !1, y = !1, T = !1, D = !1, U = 0, H, P, L = { value: "", depth: 0, isGlob: !1 };
  const E = () => u >= n, w = () => l.charCodeAt(u + 1), $ = () => (H = P, l.charCodeAt(++u));
  for (; u < n; ) {
    P = $();
    let v;
    if (P === He) {
      C = L.backslashes = !0, P = $(), P === Nt && (I = !0);
      continue;
    }
    if (I === !0 || P === Nt) {
      for (U++; E() !== !0 && (P = $()); ) {
        if (P === He) {
          C = L.backslashes = !0, $();
          continue;
        }
        if (P === Nt) {
          U++;
          continue;
        }
        if (I !== !0 && P === It && (P = $()) === It) {
          if (g = L.isBrace = !0, b = L.isGlob = !0, D = !0, i === !0)
            continue;
          break;
        }
        if (I !== !0 && P === Wa) {
          if (g = L.isBrace = !0, b = L.isGlob = !0, D = !0, i === !0)
            continue;
          break;
        }
        if (P === Qa && (U--, U === 0)) {
          I = !1, g = L.isBrace = !0, D = !0;
          break;
        }
      }
      if (i === !0)
        continue;
      break;
    }
    if (P === Dn) {
      if (s.push(u), o.push(L), L = { value: "", depth: 0, isGlob: !1 }, D === !0) continue;
      if (H === It && u === c + 1) {
        c += 2;
        continue;
      }
      d = u + 1;
      continue;
    }
    if (r.noext !== !0 && (P === Za || P === za || P === Tt || P === tn || P === xt) === !0 && w() === Ct) {
      if (b = L.isGlob = !0, N = L.isExtglob = !0, D = !0, P === xt && u === c && (T = !0), i === !0) {
        for (; E() !== !0 && (P = $()); ) {
          if (P === He) {
            C = L.backslashes = !0, P = $();
            continue;
          }
          if (P === rn) {
            b = L.isGlob = !0, D = !0;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (P === Tt) {
      if (H === Tt && (R = L.isGlobstar = !0), b = L.isGlob = !0, D = !0, i === !0)
        continue;
      break;
    }
    if (P === tn) {
      if (b = L.isGlob = !0, D = !0, i === !0)
        continue;
      break;
    }
    if (P === Ya) {
      for (; E() !== !0 && (v = $()); ) {
        if (v === He) {
          C = L.backslashes = !0, $();
          continue;
        }
        if (v === Ja) {
          h = L.isBracket = !0, b = L.isGlob = !0, D = !0;
          break;
        }
      }
      if (i === !0)
        continue;
      break;
    }
    if (r.nonegate !== !0 && P === xt && u === c) {
      y = L.negated = !0, c++;
      continue;
    }
    if (r.noparen !== !0 && P === Ct) {
      if (b = L.isGlob = !0, i === !0) {
        for (; E() !== !0 && (P = $()); ) {
          if (P === Ct) {
            C = L.backslashes = !0, P = $();
            continue;
          }
          if (P === rn) {
            D = !0;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (b === !0) {
      if (D = !0, i === !0)
        continue;
      break;
    }
  }
  r.noext === !0 && (N = !1, b = !1);
  let S = l, f = "", p = "";
  c > 0 && (f = l.slice(0, c), l = l.slice(c), d -= c), S && b === !0 && d > 0 ? (S = l.slice(0, d), p = l.slice(d)) : b === !0 ? (S = "", p = l) : S = l, S && S !== "" && S !== "/" && S !== l && nn(S.charCodeAt(S.length - 1)) && (S = S.slice(0, -1)), r.unescape === !0 && (p && (p = en.removeBackslashes(p)), S && C === !0 && (S = en.removeBackslashes(S)));
  const m = {
    prefix: f,
    input: e,
    start: c,
    base: S,
    glob: p,
    isBrace: g,
    isBracket: h,
    isGlob: b,
    isExtglob: N,
    isGlobstar: R,
    negated: y,
    negatedExtglob: T
  };
  if (r.tokens === !0 && (m.maxDepth = 0, nn(P) || o.push(L), m.tokens = o), r.parts === !0 || r.tokens === !0) {
    let v;
    for (let A = 0; A < s.length; A++) {
      const x = v ? v + 1 : c, j = s[A], q = e.slice(x, j);
      r.tokens && (A === 0 && c !== 0 ? (o[A].isPrefix = !0, o[A].value = f) : o[A].value = q, sn(o[A]), m.maxDepth += o[A].depth), (A !== 0 || q !== "") && a.push(q), v = j;
    }
    if (v && v + 1 < e.length) {
      const A = e.slice(v + 1);
      a.push(A), r.tokens && (o[o.length - 1].value = A, sn(o[o.length - 1]), m.maxDepth += o[o.length - 1].depth);
    }
    m.slashes = s, m.parts = a;
  }
  return m;
};
var tl = el;
const Je = pt, ue = Fe, {
  MAX_LENGTH: et,
  POSIX_REGEX_SOURCE: rl,
  REGEX_NON_SPECIAL_CHARS: nl,
  REGEX_SPECIAL_CHARS_BACKREF: sl,
  REPLACEMENTS: Hn
} = Je, il = (e, t) => {
  if (typeof t.expandRange == "function")
    return t.expandRange(...e, t);
  e.sort();
  const r = `[${e.join("-")}]`;
  try {
    new RegExp(r);
  } catch {
    return e.map((i) => ue.escapeRegex(i)).join("..");
  }
  return r;
}, Oe = (e, t) => `Missing ${e}: "${t}" - use "\\\\${t}" to match literal characters`, nr = (e, t) => {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  e = Hn[e] || e;
  const r = { ...t }, n = typeof r.maxLength == "number" ? Math.min(et, r.maxLength) : et;
  let i = e.length;
  if (i > n)
    throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${n}`);
  const s = { type: "bos", value: "", output: r.prepend || "" }, o = [s], a = r.capture ? "" : "?:", l = Je.globChars(r.windows), u = Je.extglobChars(l), {
    DOT_LITERAL: c,
    PLUS_LITERAL: d,
    SLASH_LITERAL: g,
    ONE_CHAR: h,
    DOTS_SLASH: b,
    NO_DOT: N,
    NO_DOT_SLASH: R,
    NO_DOTS_SLASH: I,
    QMARK: C,
    QMARK_NO_DOT: y,
    STAR: T,
    START_ANCHOR: D
  } = l, U = (O) => `(${a}(?:(?!${D}${O.dot ? b : c}).)*?)`, H = r.dot ? "" : N, P = r.dot ? C : y;
  let L = r.bash === !0 ? U(r) : T;
  r.capture && (L = `(${L})`), typeof r.noext == "boolean" && (r.noextglob = r.noext);
  const E = {
    input: e,
    index: -1,
    start: 0,
    dot: r.dot === !0,
    consumed: "",
    output: "",
    prefix: "",
    backtrack: !1,
    negated: !1,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: !1,
    tokens: o
  };
  e = ue.removePrefix(e, E), i = e.length;
  const w = [], $ = [], S = [];
  let f = s, p;
  const m = () => E.index === i - 1, v = E.peek = (O = 1) => e[E.index + O], A = E.advance = () => e[++E.index] || "", x = () => e.slice(E.index + 1), j = (O = "", V = 0) => {
    E.consumed += O, E.index += V;
  }, q = (O) => {
    E.output += O.output != null ? O.output : O.value, j(O.value);
  }, X = () => {
    let O = 1;
    for (; v() === "!" && (v(2) !== "(" || v(3) === "?"); )
      A(), E.start++, O++;
    return O % 2 === 0 ? !1 : (E.negated = !0, E.start++, !0);
  }, Z = (O) => {
    E[O]++, S.push(O);
  }, Y = (O) => {
    E[O]--, S.pop();
  }, G = (O) => {
    if (f.type === "globstar") {
      const V = E.braces > 0 && (O.type === "comma" || O.type === "brace"), _ = O.extglob === !0 || w.length && (O.type === "pipe" || O.type === "paren");
      O.type !== "slash" && O.type !== "paren" && !V && !_ && (E.output = E.output.slice(0, -f.output.length), f.type = "star", f.value = "*", f.output = L, E.output += f.output);
    }
    if (w.length && O.type !== "paren" && (w[w.length - 1].inner += O.value), (O.value || O.output) && q(O), f && f.type === "text" && O.type === "text") {
      f.output = (f.output || f.value) + O.value, f.value += O.value;
      return;
    }
    O.prev = f, o.push(O), f = O;
  }, Ee = (O, V) => {
    const _ = { ...u[V], conditions: 1, inner: "" };
    _.prev = f, _.parens = E.parens, _.output = E.output;
    const B = (r.capture ? "(" : "") + _.open;
    Z("parens"), G({ type: O, value: V, output: E.output ? "" : h }), G({ type: "paren", extglob: !0, value: A(), output: B }), w.push(_);
  }, ne = (O) => {
    let V = O.close + (r.capture ? ")" : ""), _;
    if (O.type === "negate") {
      let B = L;
      if (O.inner && O.inner.length > 1 && O.inner.includes("/") && (B = U(r)), (B !== L || m() || /^\)+$/.test(x())) && (V = O.close = `)$))${B}`), O.inner.includes("*") && (_ = x()) && /^\.[^\\/.]+$/.test(_)) {
        const K = nr(_, { ...t, fastpaths: !1 }).output;
        V = O.close = `)${K})${B})`;
      }
      O.prev.type === "bos" && (E.negatedExtglob = !0);
    }
    G({ type: "paren", extglob: !0, value: p, output: V }), Y("parens");
  };
  if (r.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(e)) {
    let O = !1, V = e.replace(sl, (_, B, K, te, Q, dt) => te === "\\" ? (O = !0, _) : te === "?" ? B ? B + te + (Q ? C.repeat(Q.length) : "") : dt === 0 ? P + (Q ? C.repeat(Q.length) : "") : C.repeat(K.length) : te === "." ? c.repeat(K.length) : te === "*" ? B ? B + te + (Q ? L : "") : L : B ? _ : `\\${_}`);
    return O === !0 && (r.unescape === !0 ? V = V.replace(/\\/g, "") : V = V.replace(/\\+/g, (_) => _.length % 2 === 0 ? "\\\\" : _ ? "\\" : "")), V === e && r.contains === !0 ? (E.output = e, E) : (E.output = ue.wrapOutput(V, E, t), E);
  }
  for (; !m(); ) {
    if (p = A(), p === "\0")
      continue;
    if (p === "\\") {
      const _ = v();
      if (_ === "/" && r.bash !== !0 || _ === "." || _ === ";")
        continue;
      if (!_) {
        p += "\\", G({ type: "text", value: p });
        continue;
      }
      const B = /^\\+/.exec(x());
      let K = 0;
      if (B && B[0].length > 2 && (K = B[0].length, E.index += K, K % 2 !== 0 && (p += "\\")), r.unescape === !0 ? p = A() : p += A(), E.brackets === 0) {
        G({ type: "text", value: p });
        continue;
      }
    }
    if (E.brackets > 0 && (p !== "]" || f.value === "[" || f.value === "[^")) {
      if (r.posix !== !1 && p === ":") {
        const _ = f.value.slice(1);
        if (_.includes("[") && (f.posix = !0, _.includes(":"))) {
          const B = f.value.lastIndexOf("["), K = f.value.slice(0, B), te = f.value.slice(B + 2), Q = rl[te];
          if (Q) {
            f.value = K + Q, E.backtrack = !0, A(), !s.output && o.indexOf(f) === 1 && (s.output = h);
            continue;
          }
        }
      }
      (p === "[" && v() !== ":" || p === "-" && v() === "]") && (p = `\\${p}`), p === "]" && (f.value === "[" || f.value === "[^") && (p = `\\${p}`), r.posix === !0 && p === "!" && f.value === "[" && (p = "^"), f.value += p, q({ value: p });
      continue;
    }
    if (E.quotes === 1 && p !== '"') {
      p = ue.escapeRegex(p), f.value += p, q({ value: p });
      continue;
    }
    if (p === '"') {
      E.quotes = E.quotes === 1 ? 0 : 1, r.keepQuotes === !0 && G({ type: "text", value: p });
      continue;
    }
    if (p === "(") {
      Z("parens"), G({ type: "paren", value: p });
      continue;
    }
    if (p === ")") {
      if (E.parens === 0 && r.strictBrackets === !0)
        throw new SyntaxError(Oe("opening", "("));
      const _ = w[w.length - 1];
      if (_ && E.parens === _.parens + 1) {
        ne(w.pop());
        continue;
      }
      G({ type: "paren", value: p, output: E.parens ? ")" : "\\)" }), Y("parens");
      continue;
    }
    if (p === "[") {
      if (r.nobracket === !0 || !x().includes("]")) {
        if (r.nobracket !== !0 && r.strictBrackets === !0)
          throw new SyntaxError(Oe("closing", "]"));
        p = `\\${p}`;
      } else
        Z("brackets");
      G({ type: "bracket", value: p });
      continue;
    }
    if (p === "]") {
      if (r.nobracket === !0 || f && f.type === "bracket" && f.value.length === 1) {
        G({ type: "text", value: p, output: `\\${p}` });
        continue;
      }
      if (E.brackets === 0) {
        if (r.strictBrackets === !0)
          throw new SyntaxError(Oe("opening", "["));
        G({ type: "text", value: p, output: `\\${p}` });
        continue;
      }
      Y("brackets");
      const _ = f.value.slice(1);
      if (f.posix !== !0 && _[0] === "^" && !_.includes("/") && (p = `/${p}`), f.value += p, q({ value: p }), r.literalBrackets === !1 || ue.hasRegexChars(_))
        continue;
      const B = ue.escapeRegex(f.value);
      if (E.output = E.output.slice(0, -f.value.length), r.literalBrackets === !0) {
        E.output += B, f.value = B;
        continue;
      }
      f.value = `(${a}${B}|${f.value})`, E.output += f.value;
      continue;
    }
    if (p === "{" && r.nobrace !== !0) {
      Z("braces");
      const _ = {
        type: "brace",
        value: p,
        output: "(",
        outputIndex: E.output.length,
        tokensIndex: E.tokens.length
      };
      $.push(_), G(_);
      continue;
    }
    if (p === "}") {
      const _ = $[$.length - 1];
      if (r.nobrace === !0 || !_) {
        G({ type: "text", value: p, output: p });
        continue;
      }
      let B = ")";
      if (_.dots === !0) {
        const K = o.slice(), te = [];
        for (let Q = K.length - 1; Q >= 0 && (o.pop(), K[Q].type !== "brace"); Q--)
          K[Q].type !== "dots" && te.unshift(K[Q].value);
        B = il(te, r), E.backtrack = !0;
      }
      if (_.comma !== !0 && _.dots !== !0) {
        const K = E.output.slice(0, _.outputIndex), te = E.tokens.slice(_.tokensIndex);
        _.value = _.output = "\\{", p = B = "\\}", E.output = K;
        for (const Q of te)
          E.output += Q.output || Q.value;
      }
      G({ type: "brace", value: p, output: B }), Y("braces"), $.pop();
      continue;
    }
    if (p === "|") {
      w.length > 0 && w[w.length - 1].conditions++, G({ type: "text", value: p });
      continue;
    }
    if (p === ",") {
      let _ = p;
      const B = $[$.length - 1];
      B && S[S.length - 1] === "braces" && (B.comma = !0, _ = "|"), G({ type: "comma", value: p, output: _ });
      continue;
    }
    if (p === "/") {
      if (f.type === "dot" && E.index === E.start + 1) {
        E.start = E.index + 1, E.consumed = "", E.output = "", o.pop(), f = s;
        continue;
      }
      G({ type: "slash", value: p, output: g });
      continue;
    }
    if (p === ".") {
      if (E.braces > 0 && f.type === "dot") {
        f.value === "." && (f.output = c);
        const _ = $[$.length - 1];
        f.type = "dots", f.output += p, f.value += p, _.dots = !0;
        continue;
      }
      if (E.braces + E.parens === 0 && f.type !== "bos" && f.type !== "slash") {
        G({ type: "text", value: p, output: c });
        continue;
      }
      G({ type: "dot", value: p, output: c });
      continue;
    }
    if (p === "?") {
      if (!(f && f.value === "(") && r.noextglob !== !0 && v() === "(" && v(2) !== "?") {
        Ee("qmark", p);
        continue;
      }
      if (f && f.type === "paren") {
        const B = v();
        let K = p;
        (f.value === "(" && !/[!=<:]/.test(B) || B === "<" && !/<([!=]|\w+>)/.test(x())) && (K = `\\${p}`), G({ type: "text", value: p, output: K });
        continue;
      }
      if (r.dot !== !0 && (f.type === "slash" || f.type === "bos")) {
        G({ type: "qmark", value: p, output: y });
        continue;
      }
      G({ type: "qmark", value: p, output: C });
      continue;
    }
    if (p === "!") {
      if (r.noextglob !== !0 && v() === "(" && (v(2) !== "?" || !/[!=<:]/.test(v(3)))) {
        Ee("negate", p);
        continue;
      }
      if (r.nonegate !== !0 && E.index === 0) {
        X();
        continue;
      }
    }
    if (p === "+") {
      if (r.noextglob !== !0 && v() === "(" && v(2) !== "?") {
        Ee("plus", p);
        continue;
      }
      if (f && f.value === "(" || r.regex === !1) {
        G({ type: "plus", value: p, output: d });
        continue;
      }
      if (f && (f.type === "bracket" || f.type === "paren" || f.type === "brace") || E.parens > 0) {
        G({ type: "plus", value: p });
        continue;
      }
      G({ type: "plus", value: d });
      continue;
    }
    if (p === "@") {
      if (r.noextglob !== !0 && v() === "(" && v(2) !== "?") {
        G({ type: "at", extglob: !0, value: p, output: "" });
        continue;
      }
      G({ type: "text", value: p });
      continue;
    }
    if (p !== "*") {
      (p === "$" || p === "^") && (p = `\\${p}`);
      const _ = nl.exec(x());
      _ && (p += _[0], E.index += _[0].length), G({ type: "text", value: p });
      continue;
    }
    if (f && (f.type === "globstar" || f.star === !0)) {
      f.type = "star", f.star = !0, f.value += p, f.output = L, E.backtrack = !0, E.globstar = !0, j(p);
      continue;
    }
    let O = x();
    if (r.noextglob !== !0 && /^\([^?]/.test(O)) {
      Ee("star", p);
      continue;
    }
    if (f.type === "star") {
      if (r.noglobstar === !0) {
        j(p);
        continue;
      }
      const _ = f.prev, B = _.prev, K = _.type === "slash" || _.type === "bos", te = B && (B.type === "star" || B.type === "globstar");
      if (r.bash === !0 && (!K || O[0] && O[0] !== "/")) {
        G({ type: "star", value: p, output: "" });
        continue;
      }
      const Q = E.braces > 0 && (_.type === "comma" || _.type === "brace"), dt = w.length && (_.type === "pipe" || _.type === "paren");
      if (!K && _.type !== "paren" && !Q && !dt) {
        G({ type: "star", value: p, output: "" });
        continue;
      }
      for (; O.slice(0, 3) === "/**"; ) {
        const ke = e[E.index + 4];
        if (ke && ke !== "/")
          break;
        O = O.slice(3), j("/**", 3);
      }
      if (_.type === "bos" && m()) {
        f.type = "globstar", f.value += p, f.output = U(r), E.output = f.output, E.globstar = !0, j(p);
        continue;
      }
      if (_.type === "slash" && _.prev.type !== "bos" && !te && m()) {
        E.output = E.output.slice(0, -(_.output + f.output).length), _.output = `(?:${_.output}`, f.type = "globstar", f.output = U(r) + (r.strictSlashes ? ")" : "|$)"), f.value += p, E.globstar = !0, E.output += _.output + f.output, j(p);
        continue;
      }
      if (_.type === "slash" && _.prev.type !== "bos" && O[0] === "/") {
        const ke = O[1] !== void 0 ? "|$" : "";
        E.output = E.output.slice(0, -(_.output + f.output).length), _.output = `(?:${_.output}`, f.type = "globstar", f.output = `${U(r)}${g}|${g}${ke})`, f.value += p, E.output += _.output + f.output, E.globstar = !0, j(p + A()), G({ type: "slash", value: "/", output: "" });
        continue;
      }
      if (_.type === "bos" && O[0] === "/") {
        f.type = "globstar", f.value += p, f.output = `(?:^|${g}|${U(r)}${g})`, E.output = f.output, E.globstar = !0, j(p + A()), G({ type: "slash", value: "/", output: "" });
        continue;
      }
      E.output = E.output.slice(0, -f.output.length), f.type = "globstar", f.output = U(r), f.value += p, E.output += f.output, E.globstar = !0, j(p);
      continue;
    }
    const V = { type: "star", value: p, output: L };
    if (r.bash === !0) {
      V.output = ".*?", (f.type === "bos" || f.type === "slash") && (V.output = H + V.output), G(V);
      continue;
    }
    if (f && (f.type === "bracket" || f.type === "paren") && r.regex === !0) {
      V.output = p, G(V);
      continue;
    }
    (E.index === E.start || f.type === "slash" || f.type === "dot") && (f.type === "dot" ? (E.output += R, f.output += R) : r.dot === !0 ? (E.output += I, f.output += I) : (E.output += H, f.output += H), v() !== "*" && (E.output += h, f.output += h)), G(V);
  }
  for (; E.brackets > 0; ) {
    if (r.strictBrackets === !0) throw new SyntaxError(Oe("closing", "]"));
    E.output = ue.escapeLast(E.output, "["), Y("brackets");
  }
  for (; E.parens > 0; ) {
    if (r.strictBrackets === !0) throw new SyntaxError(Oe("closing", ")"));
    E.output = ue.escapeLast(E.output, "("), Y("parens");
  }
  for (; E.braces > 0; ) {
    if (r.strictBrackets === !0) throw new SyntaxError(Oe("closing", "}"));
    E.output = ue.escapeLast(E.output, "{"), Y("braces");
  }
  if (r.strictSlashes !== !0 && (f.type === "star" || f.type === "bracket") && G({ type: "maybe_slash", value: "", output: `${g}?` }), E.backtrack === !0) {
    E.output = "";
    for (const O of E.tokens)
      E.output += O.output != null ? O.output : O.value, O.suffix && (E.output += O.suffix);
  }
  return E;
};
nr.fastpaths = (e, t) => {
  const r = { ...t }, n = typeof r.maxLength == "number" ? Math.min(et, r.maxLength) : et, i = e.length;
  if (i > n)
    throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${n}`);
  e = Hn[e] || e;
  const {
    DOT_LITERAL: s,
    SLASH_LITERAL: o,
    ONE_CHAR: a,
    DOTS_SLASH: l,
    NO_DOT: u,
    NO_DOTS: c,
    NO_DOTS_SLASH: d,
    STAR: g,
    START_ANCHOR: h
  } = Je.globChars(r.windows), b = r.dot ? c : u, N = r.dot ? d : u, R = r.capture ? "" : "?:", I = { negated: !1, prefix: "" };
  let C = r.bash === !0 ? ".*?" : g;
  r.capture && (C = `(${C})`);
  const y = (H) => H.noglobstar === !0 ? C : `(${R}(?:(?!${h}${H.dot ? l : s}).)*?)`, T = (H) => {
    switch (H) {
      case "*":
        return `${b}${a}${C}`;
      case ".*":
        return `${s}${a}${C}`;
      case "*.*":
        return `${b}${C}${s}${a}${C}`;
      case "*/*":
        return `${b}${C}${o}${a}${N}${C}`;
      case "**":
        return b + y(r);
      case "**/*":
        return `(?:${b}${y(r)}${o})?${N}${a}${C}`;
      case "**/*.*":
        return `(?:${b}${y(r)}${o})?${N}${C}${s}${a}${C}`;
      case "**/.*":
        return `(?:${b}${y(r)}${o})?${s}${a}${C}`;
      default: {
        const P = /^(.*?)\.(\w+)$/.exec(H);
        if (!P) return;
        const L = T(P[1]);
        return L ? L + s + P[2] : void 0;
      }
    }
  }, D = ue.removePrefix(e, I);
  let U = T(D);
  return U && r.strictSlashes !== !0 && (U += `${o}?`), U;
};
var ol = nr;
const al = tl, jt = ol, jn = Fe, ll = pt, cl = (e) => e && typeof e == "object" && !Array.isArray(e), W = (e, t, r = !1) => {
  if (Array.isArray(e)) {
    const c = e.map((g) => W(g, t, r));
    return (g) => {
      for (const h of c) {
        const b = h(g);
        if (b) return b;
      }
      return !1;
    };
  }
  const n = cl(e) && e.tokens && e.input;
  if (e === "" || typeof e != "string" && !n)
    throw new TypeError("Expected pattern to be a non-empty string");
  const i = t || {}, s = i.windows, o = n ? W.compileRe(e, t) : W.makeRe(e, t, !1, !0), a = o.state;
  delete o.state;
  let l = () => !1;
  if (i.ignore) {
    const c = { ...t, ignore: null, onMatch: null, onResult: null };
    l = W(i.ignore, c, r);
  }
  const u = (c, d = !1) => {
    const { isMatch: g, match: h, output: b } = W.test(c, o, t, { glob: e, posix: s }), N = { glob: e, state: a, regex: o, posix: s, input: c, output: b, match: h, isMatch: g };
    return typeof i.onResult == "function" && i.onResult(N), g === !1 ? (N.isMatch = !1, d ? N : !1) : l(c) ? (typeof i.onIgnore == "function" && i.onIgnore(N), N.isMatch = !1, d ? N : !1) : (typeof i.onMatch == "function" && i.onMatch(N), d ? N : !0);
  };
  return r && (u.state = a), u;
};
W.test = (e, t, r, { glob: n, posix: i } = {}) => {
  if (typeof e != "string")
    throw new TypeError("Expected input to be a string");
  if (e === "")
    return { isMatch: !1, output: "" };
  const s = r || {}, o = s.format || (i ? jn.toPosixSlashes : null);
  let a = e === n, l = a && o ? o(e) : e;
  return a === !1 && (l = o ? o(e) : e, a = l === n), (a === !1 || s.capture === !0) && (s.matchBase === !0 || s.basename === !0 ? a = W.matchBase(e, t, r, i) : a = t.exec(l)), { isMatch: !!a, match: a, output: l };
};
W.matchBase = (e, t, r) => (t instanceof RegExp ? t : W.makeRe(t, r)).test(jn.basename(e));
W.isMatch = (e, t, r) => W(t, r)(e);
W.parse = (e, t) => Array.isArray(e) ? e.map((r) => W.parse(r, t)) : jt(e, { ...t, fastpaths: !1 });
W.scan = (e, t) => al(e, t);
W.compileRe = (e, t, r = !1, n = !1) => {
  if (r === !0)
    return e.output;
  const i = t || {}, s = i.contains ? "" : "^", o = i.contains ? "" : "$";
  let a = `${s}(?:${e.output})${o}`;
  e && e.negated === !0 && (a = `^(?!${a}).*$`);
  const l = W.toRegex(a, t);
  return n === !0 && (l.state = e), l;
};
W.makeRe = (e, t = {}, r = !1, n = !1) => {
  if (!e || typeof e != "string")
    throw new TypeError("Expected a non-empty string");
  let i = { negated: !1, fastpaths: !0 };
  return t.fastpaths !== !1 && (e[0] === "." || e[0] === "*") && (i.output = jt.fastpaths(e, t)), i.output || (i = jt(e, t)), W.compileRe(i, t, r, n);
};
W.toRegex = (e, t) => {
  try {
    const r = t || {};
    return new RegExp(e, r.flags || (r.nocase ? "i" : ""));
  } catch (r) {
    if (t && t.debug === !0) throw r;
    return /$^/;
  }
};
W.constants = ll;
var ul = W;
const Gn = ul, fl = Fe;
function Bn(e, t, r = !1) {
  return t && (t.windows === null || t.windows === void 0) && (t = { ...t, windows: fl.isWindows() }), Gn(e, t, r);
}
Object.assign(Bn, Gn);
var pl = Bn;
const on = /* @__PURE__ */ nt(pl), hl = "updates", dl = "16.3.7", gl = "Flexible npm and poetry dependency update tool", El = "silverwind", ml = "silverwind/updates", $l = "BSD-2-Clause", vl = "dist/index.js", yl = "dist/index.d.ts", Rl = "module", Al = [
  "dist"
], wl = {
  node: ">=18"
}, _l = {
  "@types/minimist": "1.2.5",
  "@types/node": "22.2.0",
  "@types/picomatch": "3.0.1",
  "@types/rc": "1.2.4",
  "@types/registry-auth-token": "4.2.4",
  "@types/semver": "7.5.8",
  "ansi-regex": "6.0.1",
  eslint: "8.57.0",
  "eslint-config-silverwind": "91.0.1",
  "eslint-config-silverwind-typescript": "8.0.3",
  execa: "8.0.1",
  glowie: "1.3.2",
  minimist: "1.2.8",
  "p-all": "5.0.0",
  picomatch: "4.0.2",
  rc: "1.2.8",
  "registry-auth-token": "4.2.2",
  restana: "4.9.9",
  semver: "7.3.8",
  "smol-toml": "1.3.0",
  "supports-color": "9.4.0",
  timerel: "5.8.0",
  typescript: "5.5.4",
  "typescript-config-silverwind": "6.0.0",
  versions: "12.1.2",
  vite: "5.4.0",
  "vite-config-silverwind": "3.0.0",
  "vite-plugin-dts": "3.9.1",
  vitest: "2.0.5",
  "vitest-config-silverwind": "9.1.0"
}, Sl = {
  name: hl,
  version: dl,
  description: gl,
  author: El,
  repository: ml,
  license: $l,
  bin: vl,
  types: yl,
  type: Rl,
  files: Al,
  engines: wl,
  devDependencies: _l
}, bl = /^.*?:\/\/(.*?@)?(github\.com[:/])/i, Ol = /^([^/]+)\/([^/#]+)?.*?\/([0-9a-f]+|v?[0-9]+\.[0-9]+\.[0-9]+)$/i, Gt = /^[0-9a-f]{7,}$/i, an = /[0-9]+(\.[0-9]+)?(\.[0-9]+)?/g, tt = (e) => e.replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&"), Me = (e) => e.endsWith("/") ? e.substring(0, e.length - 1) : e, Fn = Sl.version, fe = "\0", Bt = {
  "package.json": "npm",
  "pyproject.toml": "pypi",
  "go.mod": "go"
}, M = os(Yn.slice(2), {
  boolean: [
    "E",
    "error-on-outdated",
    "U",
    "error-on-unchanged",
    "h",
    "help",
    "j",
    "json",
    "n",
    "no-color",
    "u",
    "update",
    "v",
    "version",
    "V",
    "verbose"
  ],
  string: [
    "d",
    "allow-downgrade",
    "f",
    "file",
    "g",
    "greatest",
    "m",
    "minor",
    "M",
    "modes",
    "P",
    "patch",
    "p",
    "prerelease",
    "R",
    "release",
    "r",
    "registry",
    "t",
    "types",
    "githubapi",
    // undocumented, only for tests
    "pypiapi",
    // undocumented, only for tests
    "goproxy"
    // undocumented, only for tests
  ],
  alias: {
    d: "allow-downgrade",
    E: "error-on-outdated",
    U: "error-on-unchanged",
    e: "exclude",
    f: "file",
    g: "greatest",
    h: "help",
    i: "include",
    j: "json",
    m: "minor",
    M: "modes",
    n: "no-color",
    P: "patch",
    p: "prerelease",
    r: "registry",
    R: "release",
    s: "semver",
    S: "sockets",
    t: "types",
    u: "update",
    v: "version",
    V: "verbose"
  }
});
(M["no-color"] || !Na.stdout) && Ca();
const Te = Ue($e(M.greatest)), Lt = Ue($e(M.prerelease)), Pt = Ue($e(M.release)), ln = Ue($e(M.patch)), cn = Ue($e(M.minor)), un = $e(M["allow-downgrade"]), Tl = $e(M.modes) || /* @__PURE__ */ new Set(["npm", "pypi"]), Mn = M.githubapi ? Me(M.githubapi) : "https://api.github.com", Il = M.pypiapi ? Me(M.pypiapi) : "https://pypi.org", xl = "https://proxy.golang.org", Nl = M.goproxy ? Me(M.goproxy) : Ll(), xe = (e) => e.replace(/^v/, "");
function ye(e, t) {
  for (const r of t instanceof Set ? t : [])
    if (r.test(e)) return !0;
  return !1;
}
function Cl(e, t) {
  const r = t[`${e}:registry`] || t.registry;
  return r.endsWith("/") ? r : `${r}/`;
}
function Ll() {
  return Ie.GOPROXY ? Ie.GOPROXY.split(/[,|]/).map((e) => e.trim()).filter((e) => !!e && e !== "direct") : [xl];
}
function Pl(e, t) {
  return t.split(".").reduce((r, n) => r?.[n] ?? null, e);
}
function Un(e, t) {
  const r = Vt(t, e);
  try {
    return ts(r), r;
  } catch {
  }
  const n = kt(t);
  return n === t ? null : Un(e, n);
}
function Dl(e, t, r, n) {
  if (e.startsWith("@")) {
    const i = (/@[a-z0-9][\w-.]+/.exec(e) || [""])[0], s = Me(Cl(i, n));
    if (s !== t)
      try {
        const o = vt(s, r);
        if (o?.token) return { auth: o, registry: s };
      } catch {
      }
    return { auth: vt(t, r), registry: t };
  } else
    return { auth: vt(t, r), registry: t };
}
function sr(e, t, r) {
  return {
    ...Object.keys(e).length && { agentOpts: e },
    headers: {
      "user-agent": `updates/${Fn}`,
      ...r && { Authorization: `${t} ${r}` }
    }
  };
}
async function ht(e, t) {
  M.verbose && console.error(`${La("fetch")} ${e}`);
  const r = await fetch(e, t);
  return M.verbose && console.error(`${r.ok ? er(r.status) : Jt(r.status)} ${e}`), r;
}
async function Hl(e, t, r, n, i, s) {
  const { auth: o, registry: a } = Dl(e, r, i, s), l = t === "resolutions" ? We(e) : e, u = `${a}/${l.replace(/\//g, "%2f")}`, c = await ht(u, sr(n, o?.type, o?.token));
  if (c?.ok)
    return [await c.json(), t, a, e];
  throw c?.status && c?.statusText ? new Error(`Received ${c.status} ${c.statusText} from ${u}`) : new Error(`Unable to fetch ${e} from ${a}`);
}
async function jl(e, t, r) {
  const n = `${Il}/pypi/${e}/json`, i = await ht(n, sr(r));
  if (i?.ok)
    return [await i.json(), t, null, e];
  throw i?.status && i?.statusText ? new Error(`Received ${i.status} ${i.statusText} from ${n}`) : new Error(`Unable to fetch ${e} from PyPi`);
}
function Gl(e) {
  return e.split(/\r?\n/).map((t) => t.trim()).filter(Boolean);
}
async function kn(e, t, r, n) {
  const i = n.shift();
  if (!i)
    throw new Error("No more go proxies available");
  const s = `${i}/${e.toLowerCase()}/@latest`, o = await ht(s, sr(r));
  if ([404, 410].includes(o.status) && n.length)
    return kn(e, t, r, n);
  if (o?.ok)
    return o.json();
  throw o?.status && o?.statusText ? new Error(`Received ${o.status} ${o.statusText} from ${s}`) : new Error(`Unable to fetch ${e} from PyPi`);
}
function Bl(e) {
  return e = e.replace("git@", "").replace(/.+?\/\//, "https://").replace(/\.git$/, ""), /^[a-z]+:[a-z0-9-]\/[a-z0-9-]$/.test(e) ? e.replace(/^(.+?):/, (t, r) => `https://${r}.com/`) : /^[a-z0-9-]\/[a-z0-9-]$/.test(e) ? `https://github.com/${e}` : e;
}
function Fl(e) {
  return e.startsWith("https://bitbucket.org") ? "src/HEAD" : "tree/HEAD";
}
function fn({ repository: e, homepage: t, info: r }, n, i) {
  r && (e = r.project_urls.repository || r.project_urls.Repository || r.project_urls.repo || r.project_urls.Repo || r.project_urls.source || r.project_urls.Source || r.project_urls["source code"] || r.project_urls["Source Code"] || r.project_urls.homepage || r.project_urls.Homepage || `https://pypi.org/project/${i}/`);
  let s = "";
  if (n === "https://npm.pkg.github.com")
    return `https://github.com/${i.replace(/^@/, "")}`;
  if (e) {
    const o = typeof e == "string" ? e : e.url;
    s = Bl(o), s && typeof e != "string" && e.directory && (s = `${s}/${Fl(s)}/${e.directory}`);
  }
  return s || t || "";
}
function pn(e) {
  console.info(M.json ? JSON.stringify({ message: e }) : e), Ge();
}
function Ge(e) {
  if (e) {
    const t = e.stack ?? e.message;
    console.info(M.json ? JSON.stringify({ error: t }) : Jt(t));
  }
  process.exit(e ? 1 : 0);
}
function Ml(e = {}) {
  for (const r of Object.keys(e))
    for (const n of Object.values(e[r]))
      typeof n.oldPrint == "string" && (n.old = n.oldPrint, delete n.oldPrint), typeof n.newPrint == "string" && (n.new = n.newPrint, delete n.newPrint), typeof n.oldOriginal == "string" && (n.old = n.oldOriginal, delete n.oldOriginal);
  let t = 0;
  for (const r of Object.keys(e))
    t += Object.keys(e[r]).length;
  if (M.json) {
    const r = { results: {} };
    for (const n of Object.keys(e))
      for (const [i, s] of Object.entries(e[n])) {
        const [o, a] = i.split(fe);
        r.results[n] || (r.results[n] = {}), r.results[n][o] || (r.results[n][o] = {}), r.results[n][o][a] = s;
      }
    console.info(JSON.stringify(r));
  } else t && console.info(Xl(e));
  return M["error-on-outdated"] ? t ? 2 : 0 : M["error-on-unchanged"] ? t ? 0 : 2 : 0;
}
async function Ul(e, t) {
  const { platform: r } = await import("node:os"), n = r() === "win32";
  n && Jn(e, 0), es(e, t, n ? { flag: "r+" } : void 0);
}
function hn(e, t, r) {
  if (e === t) return e;
  const n = e.split(/\./), i = t.split(/\./), s = /^[0-9a-zA-Z-.]+$/;
  let o = "";
  for (let a = 0; a < n.length; a++)
    if (n[a] !== i[a]) {
      s.test(n[a]) ? o += r(n.slice(a).join(".")) : o += n[a].split("").map((l) => s.test(l) ? r(l) : l).join("") + r(`.${n.slice(a + 1).join(".")}`.replace(/\.$/, ""));
      break;
    } else
      o += `${n[a]}.`;
  return o.replace(/\.$/, "");
}
const dn = (e) => e.replace(ss(), "").length;
function kl(e, t = " ") {
  let r = "";
  const n = new Array(e[0].length).fill(0);
  for (const i of e)
    for (const [s, o] of i.entries()) {
      const a = dn(o);
      a > n[s] && (n[s] = a);
    }
  for (const [i, s] of e.entries()) {
    for (const [o, a] of s.entries()) {
      o > 0 && (r += t);
      const l = " ".repeat(n[o] - dn(a));
      r += a + (o === s.length - 1 ? "" : l);
    }
    i < e.length - 1 && (r += `
`);
  }
  return r;
}
function Vl(e) {
  return /\/v[0-9]$/.test(e) && (e = kt(e)), e;
}
function Xl(e) {
  const t = [["NAME", "OLD", "NEW", "AGE", "INFO"]], r = /* @__PURE__ */ new Set();
  for (const n of Object.keys(e))
    for (const [i, s] of Object.entries(e[n])) {
      const o = i.split(fe)[1], a = `${n}|${o}`;
      r.has(a) || (r.add(a), t.push([
        n === "go" ? Vl(o) : o,
        hn(s.old, s.new, Jt),
        hn(s.new, s.old, er),
        s.age || "",
        s.info || ""
      ]));
    }
  return kl(t);
}
function ql(e, t) {
  let r = e;
  for (const n of Object.keys(t)) {
    const i = n.split(fe)[1], s = t[n].oldOriginal || t[n].old, o = new RegExp(`"${tt(i)}": *"${tt(s)}"`, "g");
    r = r.replace(o, `"${i}": "${t[n].new}"`);
  }
  return r;
}
function Kl(e, t) {
  let r = e;
  for (const n of Object.keys(t)) {
    const i = n.split(fe)[1], s = t[n].oldOriginal || t[n].old, o = new RegExp(`${tt(i)} *= *"${tt(s)}"`, "g");
    r = r.replace(o, `${i} = "${t[n].new}"`);
  }
  return r;
}
function zl(e, t, r) {
  let n = e.replace(/[0-9]+\.[0-9]+\.[0-9]+(-.+)?/g, t);
  if (r && r !== e && /^[\^~]/.test(n)) {
    const i = r.substring(1).split("."), s = n.substring(1).split(".");
    i.length !== s.length && (n = `${n[0]}${s.slice(0, i.length).join(".")}`);
  }
  return n;
}
function Dt(e) {
  const t = ee.parse(e);
  return t ? !!t.prerelease.length : !1;
}
function Vn(e) {
  return /[0-9]+\.[0-9]+\.[0-9]+-.+/.test(e);
}
function Be(e) {
  try {
    return ee.coerce(e)?.version ?? "";
  } catch {
    return "";
  }
}
function Wl(e, t, { range: r, semvers: n, usePre: i, useRel: s, useGreatest: o }) {
  let a = Be(r), l = 0;
  i = Vn(r) || i, i && (n.add("prerelease"), n.has("patch") && n.add("prepatch"), n.has("minor") && n.add("preminor"), n.has("major") && n.add("premajor"));
  for (const u of t) {
    const c = ee.parse(u);
    if (!c || !a || c.prerelease.length && (!i || s)) continue;
    const d = ee.diff(a, c.version);
    if (!(!d || !n.has(d)))
      if (o || !("time" in e))
        ee.gte(Be(c?.version), a) && (a = c.version);
      else {
        const g = new Date(e.time[u]).getTime();
        g >= 0 && g > l && (a = c.version, l = g);
      }
  }
  return a || null;
}
function Yl(e, { mode: t, range: r, useGreatest: n, useRel: i, usePre: s, semvers: o }) {
  if (t === "go")
    return ee.gt(xe(e.Version), xe(r)) ? e.Version : null;
  if (r === "*" || r.includes("||")) return null;
  let a = [];
  t === "pypi" ? a = Object.keys(e.releases).filter((u) => ee.valid(u)) : t === "npm" && (a = Object.keys(e.versions).filter((u) => ee.valid(u)));
  const l = Wl(e, a, { range: r, semvers: o, usePre: s, useRel: i, useGreatest: n });
  if (!l) return null;
  if (n)
    return l;
  {
    let u = "", c = "";
    t === "pypi" ? (c = e.info.version, u = Be(e.info.version)) : u = e["dist-tags"].latest;
    const d = Be(r), g = Vn(r), h = Dt(l), b = Dt(u), N = ee.gt(l, d);
    if (!i && s || g && h || i && !N && g && !h || g && !h && N)
      return l;
    if (g && !h && !N)
      return null;
    const R = ee.diff(d, u);
    return R && R !== "prerelease" && !o.has(R.replace(/^pre/, "")) || i && Dt(u) ? l : ee.lt(u, d) && !b ? un === !0 || ye(e.name, un) ? u : null : c || u;
  }
}
function Xn(e) {
  const t = {}, r = Ie.UPDATES_GITHUB_API_TOKEN || Ie.GITHUB_API_TOKEN || Ie.GH_TOKEN || Ie.HOMEBREW_GITHUB_API_TOKEN;
  return r && (t.headers = { Authorization: `Bearer ${r}` }), ht(e, t);
}
async function Zl(e, t) {
  const r = `${Mn}/repos/${e}/${t}/commits`, n = await Xn(r);
  if (!n?.ok) return { hash: "", commit: {} };
  const i = await n.json(), { sha: s, commit: o } = i[0];
  return { hash: s, commit: o };
}
async function Ql(e, t) {
  const r = await Xn(`${Mn}/repos/${e}/${t}/git/refs/tags`);
  return r?.ok ? (await r.json()).map((s) => s.ref.replace(/^refs\/tags\//, "")) : [];
}
function Jl(e, t, r) {
  const n = xe(t);
  if (ee.valid(n))
    if (r) {
      let i = t, s = xe(t);
      for (const o of e) {
        const a = xe(o);
        ee.valid(a) && (!i || ee.gt(a, s)) && (i = o, s = a);
      }
      if (ee.neq(n, s))
        return i;
    } else {
      const i = e.at(-1);
      if (!i) return;
      const s = xe(i);
      if (!ee.valid(s)) return;
      if (ee.neq(n, s))
        return i;
    }
}
async function ec(e, t, r) {
  const n = t.old.replace(bl, ""), [i, s, o, a] = Ol.exec(n) || [];
  if (!(!s || !o || !a))
    if (Gt.test(a)) {
      const { hash: l, commit: u } = await Zl(s, o);
      if (!l) return;
      const c = u?.committer?.date ?? u?.author?.date, d = l.substring(0, a.length);
      if (a !== d) {
        const g = t.old.replace(a, d);
        return { key: e, newRange: g, user: s, repo: o, oldRef: a, newRef: d, newDate: c };
      }
    } else {
      const l = await Ql(s, o), u = Jl(l, a, r);
      if (u)
        return { key: e, newRange: u, user: s, repo: o, oldRef: a, newRef: u };
    }
}
function tc(e) {
  return e.replace(/-.*/, "");
}
function rc(e) {
  const t = e.match(an);
  return t?.length !== 1 ? e : e.replace(an, Be(t[0]));
}
function $e(e) {
  return e === void 0 ? !1 : e === "" ? !0 : typeof e == "string" ? e.includes(",") ? new Set(e.split(",")) : /* @__PURE__ */ new Set([e]) : Array.isArray(e) ? new Set(e) : !1;
}
function nc(e) {
  return Array.from(e.matchAll(/(----BEGIN CERT[^]+?IFICATE----)/g), (t) => t[0]);
}
function sc(e) {
  return Array.from(e.matchAll(/(----BEGIN [^]+?PRIVATE KEY----)/g), (t) => t[0]);
}
async function ic(e = []) {
  return [...(await import("node:tls")).rootCertificates, ...e];
}
function Ft(e, t) {
  return t && typeof e == "string" ? /\/.+\//.test(e) ? new RegExp(e.slice(1, -1)) : on.makeRe(e) : e instanceof RegExp ? e : on.makeRe(e);
}
function Ue(e) {
  if (e instanceof Set) {
    const t = /* @__PURE__ */ new Set();
    for (const r of e)
      t.add(Ft(r, !0));
    return t;
  }
  return e;
}
function gn(e, t) {
  const r = /* @__PURE__ */ new Set();
  for (const n of e || [])
    r.add(Ft(n, !0));
  for (const n of t || [])
    r.add(Ft(n, !1));
  return r;
}
function En(e, t, r, n) {
  if (t === "pypi" && e === "python") return !1;
  if (!r.size && !n.size) return !0;
  for (const i of n)
    if (i.test(e)) return !1;
  for (const i of r)
    if (i.test(e)) return !0;
  return !r.size;
}
function oc(e) {
  const t = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set();
  if (e)
    for (const n of e) {
      let i;
      try {
        i = cr(n);
      } catch (s) {
        throw new Error(`Unable to open ${n}: ${s.message}`);
      }
      if (i?.isFile()) {
        const s = ze(n);
        t.add(s), r.add(s);
      } else if (i?.isDirectory())
        for (const s of Object.keys(Bt)) {
          const o = Vt(n, s);
          let a;
          try {
            a = cr(o);
          } catch {
          }
          a?.isFile() && t.add(ze(o));
        }
      else
        throw new Error(`${n} is neither a file nor directory`);
    }
  else
    for (const n of Object.keys(Bt)) {
      const i = Un(n, Qn());
      i && t.add(ze(i));
    }
  return [t, r];
}
async function ac(e) {
  let t = {};
  try {
    ({ default: t } = await Promise.any([
      "updates.config.js",
      "updates.config.ts",
      "updates.config.mjs",
      "updates.config.mts",
      ".config/updates.js",
      ".config/updates.ts",
      ".config/updates.mjs",
      ".config/updates.mts"
    ].map((r) => import(Vt(e, ...r.split("/"))))));
  } catch {
  }
  return t;
}
async function lc() {
  for (const R of [process.stdout, process.stderr])
    R?._handle?.setBlocking?.(!0);
  const e = 96, t = typeof M.sockets == "number" ? M.sockets : e, { help: r, version: n, file: i, types: s, update: o } = M;
  r && (Zn.write(`usage: updates [options]

  Options:
    -u, --update                       Update versions and write package file
    -f, --file <path,...>              File or directory to use, defaults to current directory
    -i, --include <pkg,...>            Include only given packages
    -e, --exclude <pkg,...>            Exclude given packages
    -p, --prerelease [<pkg,...>]       Consider prerelease versions
    -R, --release [<pkg,...>]          Only use release versions, may downgrade
    -g, --greatest [<pkg,...>]         Prefer greatest over latest version
    -t, --types <type,...>             Check only given dependency types
    -P, --patch [<pkg,...>]            Consider only up to semver-patch
    -m, --minor [<pkg,...>]            Consider only up to semver-minor
    -d, --allow-downgrade [<pkg,...>]  Allow version downgrades when using latest version
    -E, --error-on-outdated            Exit with code 2 when updates are available and 0 when not
    -U, --error-on-unchanged           Exit with code 0 when updates are available and 2 when not
    -r, --registry <url>               Override npm registry URL
    -S, --sockets <num>                Maximum number of parallel HTTP sockets opened. Default: ${e}
    -M, --modes <mode,...>             Which modes to enable. Either npm,pypi,go. Default: npm,pypi
    -j, --json                         Output a JSON object
    -n, --no-color                     Disable color output
    -v, --version                      Print the version
    -V, --verbose                      Print verbose output to stderr
    -h, --help                         Print this help

  Examples:
    $ updates
    $ updates -u
    $ updates -e '@vitejs/*'
    $ updates -e '/^react-(dom)?/'
    $ updates -f package.json
    $ updates -f pyproject.toml
`), ar(0)), n && (console.info(Fn), ar(0));
  const a = {}, l = {}, u = {}, c = {};
  let d = 0;
  const [g, h] = oc($e(i));
  for (const R of g) {
    const I = kt(ze(R)), C = We(R), y = Bt[C];
    if (!Tl.has(y) && !h.has(R)) continue;
    c[y] = R, a[y] || (a[y] = {});
    const T = await ac(I);
    let D = [], U = [];
    M.include && M.include !== !0 && (D = (Array.isArray(M.include) ? M.include : [M.include]).flatMap((m) => m.split(","))), M.exclude && M.exclude !== !0 && (U = (Array.isArray(M.exclude) ? M.exclude : [M.exclude]).flatMap((m) => m.split(",")));
    const H = gn(D, T?.include ?? []), P = gn(U, T?.exclude ?? []), L = {}, E = _s("npm", { registry: "https://registry.npmjs.org" }) || {}, w = { npmrc: E, recursive: !0 };
    if (y === "npm") {
      E["strict-ssl"] === !1 && (L.rejectUnauthorized = !1);
      for (const m of ["cert", "ca", "key"]) {
        const v = m === "key" ? sc : nc;
        let A = [];
        E[m] && (A = (Array.isArray(E[m]) ? E[m] : [E[m]]).flatMap((x) => v(x))), E[`${m}file`] && (A = Array.from(v(lr(E[`opt${R}`], "utf8")))), A.length && (L[m] = m === "ca" ? await ic(A) : A);
      }
    }
    let $ = [];
    s ? $ = Array.isArray(s) ? s : s.split(",") : "types" in T && Array.isArray(T.types) ? $ = T.types : y === "npm" ? $ = [
      "dependencies",
      "devDependencies",
      "optionalDependencies",
      "peerDependencies",
      "resolutions"
    ] : y === "pypi" ? $ = [
      "tool.poetry.dependencies",
      "tool.poetry.dev-dependencies",
      "tool.poetry.test-dependencies",
      "tool.poetry.group.dev.dependencies",
      "tool.poetry.group.test.dependencies"
    ] : y === "go" && ($ = [
      "deps"
    ]);
    let S = {};
    if (y === "go")
      u[y] = ns("go", [
        "list",
        "-m",
        "-f",
        "{{if not .Indirect}}{{.Path}}@{{.Version}}{{end}}",
        "all"
      ], { stdio: "pipe", encoding: "utf8", cwd: I });
    else
      try {
        u[y] = lr(R, "utf8");
      } catch (m) {
        throw new Error(`Unable to open ${R}: ${m.message}`);
      }
    try {
      if (y === "npm")
        S = JSON.parse(u[y]);
      else if (y === "pypi")
        S = (await Promise.resolve().then(() => Ac)).parse(u[y]);
      else {
        S.deps = {};
        for (const m of Gl(u[y])) {
          const [v, A] = m.split("@");
          A && (S.deps[v] = A);
        }
      }
    } catch (m) {
      throw new Error(`Error parsing ${R}: ${m.message}`);
    }
    for (const m of $) {
      let v;
      y === "npm" || y === "go" ? v = S[m] || {} : v = Pl(S, m) || {};
      for (const [A, x] of Object.entries(v))
        y !== "go" && ee.validRange(x) && En(A, y, H, P) ? a[y][`${m}${fe}${A}`] = {
          old: rc(x),
          oldOriginal: x
        } : y === "npm" && En(A, y, H, P) ? l[`${m}${fe}${A}`] = {
          old: x
        } : y === "go" && (a[y][`${m}${fe}${A}`] = {
          old: tc(x),
          oldOriginal: x
        });
    }
    if (d += Object.keys(a[y]).length + Object.keys(l).length, !d) continue;
    let f;
    y === "npm" && (f = Me(M.registry || T.registry || E.registry));
    const p = await Qr(Object.keys(a[y]).map((m) => async () => {
      const [v, A] = m.split(fe);
      if (y === "npm")
        return Hl(A, v, f, L, w, E);
      if (y === "pypi")
        return jl(A, v, L);
      {
        const x = Array.from(Nl);
        return [await kn(A, "latest", L, x), "deps", null, A];
      }
    }), { concurrency: t });
    for (const [m, v, A, x] of p) {
      if (m?.error) throw new Error(m.error);
      const j = typeof Te == "boolean" ? Te : ye(m.name, Te), q = typeof Lt == "boolean" ? Lt : ye(m.name, Lt), X = typeof Pt == "boolean" ? Pt : ye(m.name, Pt);
      let Z;
      ln === !0 || ye(m.name, ln) ? Z = /* @__PURE__ */ new Set(["patch"]) : cn === !0 || ye(m.name, cn) ? Z = /* @__PURE__ */ new Set(["patch", "minor"]) : Z = /* @__PURE__ */ new Set(["patch", "minor", "major"]);
      const Y = `${v}${fe}${x}`, G = a[y][Y].old, Ee = a[y][Y].oldOriginal, ne = Yl(m, {
        usePre: q,
        useRel: X,
        useGreatest: j,
        semvers: Z,
        range: G,
        mode: y
      });
      let O = "";
      if (y === "go" && ne ? O = ne : ne && (O = zl(G, ne, Ee)), !ne || Ee && Ee === O)
        delete a[y][Y];
      else {
        a[y][Y].new = O, y === "npm" ? a[y][Y].info = fn(m?.versions?.[ne], A, m.name) : y === "pypi" ? a[y][Y].info = fn(m, A, m.info.name) : a[y][Y].info = m?.Origin?.URL ?? `https://${x}`;
        let V = "";
        y === "npm" && m.time?.[ne] ? V = m.time[ne] : y === "pypi" && m.releases?.[ne]?.[0]?.upload_time_iso_8601 ? V = m.releases[ne][0].upload_time_iso_8601 : y === "go" && m.Time && (V = m.Time), V && (a[y][Y].age = Kr(V, { noAffix: !0 }));
      }
    }
    if (Object.keys(l).length) {
      const m = await Qr(Object.entries(l).map(([v, A]) => () => {
        const x = v.split(fe)[1], j = typeof Te == "boolean" ? Te : ye(x, Te);
        return ec(v, A, j);
      }), { concurrency: t });
      for (const v of (m || []).filter(Boolean)) {
        const { key: A, newRange: x, user: j, repo: q, oldRef: X, newRef: Z, newDate: Y } = v;
        a[y][A] = {
          // @ts-expect-error
          old: l[A].old,
          new: x,
          oldPrint: Gt.test(X) ? X.substring(0, 7) : X,
          newPrint: Gt.test(Z) ? Z.substring(0, 7) : Z,
          info: `https://github.com/${j}/${q}`,
          ...Y ? { age: Kr(Y, { noAffix: !0 }) } : {}
        };
      }
    }
  }
  d === 0 && (pn("No dependencies found, nothing to do."), Ge());
  let b = 0;
  for (const R of Object.keys(a))
    b += Object.keys(a[R]).length;
  b || (pn("All dependencies are up to date."), Ge());
  const N = Ml(a);
  if (o) {
    for (const R of Object.keys(a))
      if (Object.keys(a[R]).length) {
        try {
          const I = R === "npm" ? ql : Kl;
          await Ul(c[R], I(u[R], a[R]));
        } catch (I) {
          throw new Error(`Error writing ${We(c[R])}: ${I.message}`);
        }
        console.info(er(`✨ ${We(c[R])} updated`));
      }
  }
  process.exit(N);
}
lc().catch(Ge).then(Ge);
function cc(e, t) {
  let r = e.slice(0, t).split(/\r\n|\n|\r/g);
  return [r.length, r.pop().length + 1];
}
function uc(e, t, r) {
  let n = e.split(/\r\n|\n|\r/g), i = "", s = (Math.log10(t + 1) | 0) + 1;
  for (let o = t - 1; o <= t + 1; o++) {
    let a = n[o - 1];
    a && (i += o.toString().padEnd(s, " "), i += ":  ", i += a, i += `
`, o === t && (i += " ".repeat(s + r + 2), i += `^
`));
  }
  return i;
}
class F extends Error {
  line;
  column;
  codeblock;
  constructor(t, r) {
    const [n, i] = cc(r.toml, r.ptr), s = uc(r.toml, n, i);
    super(`Invalid TOML document: ${t}

${s}`, r), this.line = n, this.column = i, this.codeblock = s;
  }
}
function rt(e, t = 0, r = e.length) {
  let n = e.indexOf(`
`, t);
  return e[n - 1] === "\r" && n--, n <= r ? n : -1;
}
function ir(e, t) {
  for (let r = t; r < e.length; r++) {
    let n = e[r];
    if (n === `
`)
      return r;
    if (n === "\r" && e[r + 1] === `
`)
      return r + 1;
    if (n < " " && n !== "	" || n === "")
      throw new F("control characters are not allowed in comments", {
        toml: e,
        ptr: t
      });
  }
  return e.length;
}
function ge(e, t, r, n) {
  let i;
  for (; (i = e[t]) === " " || i === "	" || !r && (i === `
` || i === "\r" && e[t + 1] === `
`); )
    t++;
  return n || i !== "#" ? t : ge(e, ir(e, t), r);
}
function mn(e, t, r, n, i = !1) {
  if (!n)
    return t = rt(e, t), t < 0 ? e.length : t;
  for (let s = t; s < e.length; s++) {
    let o = e[s];
    if (o === "#")
      s = rt(e, s);
    else {
      if (o === r)
        return s + 1;
      if (o === n)
        return s;
      if (i && (o === `
` || o === "\r" && e[s + 1] === `
`))
        return s;
    }
  }
  throw new F("cannot find end of structure", {
    toml: e,
    ptr: t
  });
}
function qn(e, t) {
  let r = e[t], n = r === e[t + 1] && e[t + 1] === e[t + 2] ? e.slice(t, t + 3) : r;
  t += n.length - 1;
  do
    t = e.indexOf(n, ++t);
  while (t > -1 && r !== "'" && e[t - 1] === "\\" && e[t - 2] !== "\\");
  return t > -1 && (t += n.length, n.length > 1 && (e[t] === r && t++, e[t] === r && t++)), t;
}
let fc = /^(\d{4}-\d{2}-\d{2})?[T ]?(?:(\d{2}):\d{2}:\d{2}(?:\.\d+)?)?(Z|[-+]\d{2}:\d{2})?$/i;
class we extends Date {
  #t = !1;
  #r = !1;
  #e = null;
  constructor(t) {
    let r = !0, n = !0, i = "Z";
    if (typeof t == "string") {
      let s = t.match(fc);
      s ? (s[1] || (r = !1, t = `0000-01-01T${t}`), n = !!s[2], s[2] && +s[2] > 23 ? t = "" : (i = s[3] || null, t = t.toUpperCase(), !i && n && (t += "Z"))) : t = "";
    }
    super(t), isNaN(this.getTime()) || (this.#t = r, this.#r = n, this.#e = i);
  }
  isDateTime() {
    return this.#t && this.#r;
  }
  isLocal() {
    return !this.#t || !this.#r || !this.#e;
  }
  isDate() {
    return this.#t && !this.#r;
  }
  isTime() {
    return this.#r && !this.#t;
  }
  isValid() {
    return this.#t || this.#r;
  }
  toISOString() {
    let t = super.toISOString();
    if (this.isDate())
      return t.slice(0, 10);
    if (this.isTime())
      return t.slice(11, 23);
    if (this.#e === null)
      return t.slice(0, -1);
    if (this.#e === "Z")
      return t;
    let r = +this.#e.slice(1, 3) * 60 + +this.#e.slice(4, 6);
    return r = this.#e[0] === "-" ? r : -r, new Date(this.getTime() - r * 6e4).toISOString().slice(0, -1) + this.#e;
  }
  static wrapAsOffsetDateTime(t, r = "Z") {
    let n = new we(t);
    return n.#e = r, n;
  }
  static wrapAsLocalDateTime(t) {
    let r = new we(t);
    return r.#e = null, r;
  }
  static wrapAsLocalDate(t) {
    let r = new we(t);
    return r.#r = !1, r.#e = null, r;
  }
  static wrapAsLocalTime(t) {
    let r = new we(t);
    return r.#t = !1, r.#e = null, r;
  }
}
let pc = /^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\d(_?\d)*))$/, hc = /^[+-]?\d(_?\d)*(\.\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?$/, dc = /^[+-]?0[0-9_]/, gc = /^[0-9a-f]{4,8}$/i, $n = {
  b: "\b",
  t: "	",
  n: `
`,
  f: "\f",
  r: "\r",
  '"': '"',
  "\\": "\\"
};
function Kn(e, t = 0, r = e.length) {
  let n = e[t] === "'", i = e[t++] === e[t] && e[t] === e[t + 1];
  i && (r -= 2, e[t += 2] === "\r" && t++, e[t] === `
` && t++);
  let s = 0, o, a = "", l = t;
  for (; t < r - 1; ) {
    let u = e[t++];
    if (u === `
` || u === "\r" && e[t] === `
`) {
      if (!i)
        throw new F("newlines are not allowed in strings", {
          toml: e,
          ptr: t - 1
        });
    } else if (u < " " && u !== "	" || u === "")
      throw new F("control characters are not allowed in strings", {
        toml: e,
        ptr: t - 1
      });
    if (o) {
      if (o = !1, u === "u" || u === "U") {
        let c = e.slice(t, t += u === "u" ? 4 : 8);
        if (!gc.test(c))
          throw new F("invalid unicode escape", {
            toml: e,
            ptr: s
          });
        try {
          a += String.fromCodePoint(parseInt(c, 16));
        } catch {
          throw new F("invalid unicode escape", {
            toml: e,
            ptr: s
          });
        }
      } else if (i && (u === `
` || u === " " || u === "	" || u === "\r")) {
        if (t = ge(e, t - 1, !0), e[t] !== `
` && e[t] !== "\r")
          throw new F("invalid escape: only line-ending whitespace may be escaped", {
            toml: e,
            ptr: s
          });
        t = ge(e, t);
      } else if (u in $n)
        a += $n[u];
      else
        throw new F("unrecognized escape sequence", {
          toml: e,
          ptr: s
        });
      l = t;
    } else !n && u === "\\" && (s = t - 1, o = !0, a += e.slice(l, s));
  }
  return a + e.slice(l, r - 1);
}
function Ec(e, t, r) {
  if (e === "true")
    return !0;
  if (e === "false")
    return !1;
  if (e === "-inf")
    return -1 / 0;
  if (e === "inf" || e === "+inf")
    return 1 / 0;
  if (e === "nan" || e === "+nan" || e === "-nan")
    return NaN;
  if (e === "-0")
    return 0;
  let n;
  if ((n = pc.test(e)) || hc.test(e)) {
    if (dc.test(e))
      throw new F("leading zeroes are not allowed", {
        toml: t,
        ptr: r
      });
    let s = +e.replace(/_/g, "");
    if (isNaN(s))
      throw new F("invalid number", {
        toml: t,
        ptr: r
      });
    if (n && !Number.isSafeInteger(s))
      throw new F("integer value cannot be represented losslessly", {
        toml: t,
        ptr: r
      });
    return s;
  }
  let i = new we(e);
  if (!i.isValid())
    throw new F("invalid value", {
      toml: t,
      ptr: r
    });
  return i;
}
function mc(e, t, r, n) {
  let i = e.slice(t, r), s = i.indexOf("#");
  s > -1 && (ir(e, s), i = i.slice(0, s));
  let o = i.trimEnd();
  if (!n) {
    let a = i.indexOf(`
`, o.length);
    if (a > -1)
      throw new F("newlines are not allowed in inline tables", {
        toml: e,
        ptr: t + a
      });
  }
  return [o, s];
}
function or(e, t, r) {
  let n = e[t];
  if (n === "[" || n === "{") {
    let [o, a] = n === "[" ? yc(e, t) : vc(e, t), l = mn(e, a, ",", r);
    if (r === "}") {
      let u = rt(e, a, l);
      if (u > -1)
        throw new F("newlines are not allowed in inline tables", {
          toml: e,
          ptr: u
        });
    }
    return [o, l];
  }
  let i;
  if (n === '"' || n === "'") {
    i = qn(e, t);
    let o = Kn(e, t, i);
    if (r) {
      if (i = ge(e, i, r !== "]"), e[i] && e[i] !== "," && e[i] !== r && e[i] !== `
` && e[i] !== "\r")
        throw new F("unexpected character encountered", {
          toml: e,
          ptr: i
        });
      i += +(e[i] === ",");
    }
    return [o, i];
  }
  i = mn(e, t, ",", r);
  let s = mc(e, t, i - +(e[i - 1] === ","), r === "]");
  if (!s[0])
    throw new F("incomplete key-value declaration: no value specified", {
      toml: e,
      ptr: t
    });
  return r && s[1] > -1 && (i = ge(e, t + s[1]), i += +(e[i] === ",")), [
    Ec(s[0], e, t),
    i
  ];
}
let $c = /^[a-zA-Z0-9-_]+[ \t]*$/;
function Mt(e, t, r = "=") {
  let n = t - 1, i = [], s = e.indexOf(r, t);
  if (s < 0)
    throw new F("incomplete key-value: cannot find end of key", {
      toml: e,
      ptr: t
    });
  do {
    let o = e[t = ++n];
    if (o !== " " && o !== "	")
      if (o === '"' || o === "'") {
        if (o === e[t + 1] && o === e[t + 2])
          throw new F("multiline strings are not allowed in keys", {
            toml: e,
            ptr: t
          });
        let a = qn(e, t);
        if (a < 0)
          throw new F("unfinished string encountered", {
            toml: e,
            ptr: t
          });
        n = e.indexOf(".", a);
        let l = e.slice(a, n < 0 || n > s ? s : n), u = rt(l);
        if (u > -1)
          throw new F("newlines are not allowed in keys", {
            toml: e,
            ptr: t + n + u
          });
        if (l.trimStart())
          throw new F("found extra tokens after the string part", {
            toml: e,
            ptr: a
          });
        if (s < a && (s = e.indexOf(r, a), s < 0))
          throw new F("incomplete key-value: cannot find end of key", {
            toml: e,
            ptr: t
          });
        i.push(Kn(e, t, a));
      } else {
        n = e.indexOf(".", t);
        let a = e.slice(t, n < 0 || n > s ? s : n);
        if (!$c.test(a))
          throw new F("only letter, numbers, dashes and underscores are allowed in keys", {
            toml: e,
            ptr: t
          });
        i.push(a.trimEnd());
      }
  } while (n + 1 && n < s);
  return [i, ge(e, s + 1, !0, !0)];
}
function vc(e, t) {
  let r = {}, n = /* @__PURE__ */ new Set(), i, s = 0;
  for (t++; (i = e[t++]) !== "}" && i; ) {
    if (i === `
`)
      throw new F("newlines are not allowed in inline tables", {
        toml: e,
        ptr: t - 1
      });
    if (i === "#")
      throw new F("inline tables cannot contain comments", {
        toml: e,
        ptr: t - 1
      });
    if (i === ",")
      throw new F("expected key-value, found comma", {
        toml: e,
        ptr: t - 1
      });
    if (i !== " " && i !== "	") {
      let o, a = r, l = !1, [u, c] = Mt(e, t - 1);
      for (let h = 0; h < u.length; h++) {
        if (h && (a = l ? a[o] : a[o] = {}), o = u[h], (l = Object.hasOwn(a, o)) && (typeof a[o] != "object" || n.has(a[o])))
          throw new F("trying to redefine an already defined value", {
            toml: e,
            ptr: t
          });
        !l && o === "__proto__" && Object.defineProperty(a, o, { enumerable: !0, configurable: !0, writable: !0 });
      }
      if (l)
        throw new F("trying to redefine an already defined value", {
          toml: e,
          ptr: t
        });
      let [d, g] = or(e, c, "}");
      n.add(d), a[o] = d, t = g, s = e[t - 1] === "," ? t - 1 : 0;
    }
  }
  if (s)
    throw new F("trailing commas are not allowed in inline tables", {
      toml: e,
      ptr: s
    });
  if (!i)
    throw new F("unfinished table encountered", {
      toml: e,
      ptr: t
    });
  return [r, t];
}
function yc(e, t) {
  let r = [], n;
  for (t++; (n = e[t++]) !== "]" && n; ) {
    if (n === ",")
      throw new F("expected value, found comma", {
        toml: e,
        ptr: t - 1
      });
    if (n === "#")
      t = ir(e, t);
    else if (n !== " " && n !== "	" && n !== `
` && n !== "\r") {
      let i = or(e, t - 1, "]");
      r.push(i[0]), t = i[1];
    }
  }
  if (!n)
    throw new F("unfinished array encountered", {
      toml: e,
      ptr: t
    });
  return [r, t];
}
function vn(e, t, r, n) {
  let i = t, s = r, o, a = !1, l;
  for (let u = 0; u < e.length; u++) {
    if (u) {
      if (i = a ? i[o] : i[o] = {}, s = (l = s[o]).c, n === 0 && (l.t === 1 || l.t === 2))
        return null;
      if (l.t === 2) {
        let c = i.length - 1;
        i = i[c], s = s[c].c;
      }
    }
    if (o = e[u], (a = Object.hasOwn(i, o)) && s[o]?.t === 0 && s[o]?.d)
      return null;
    a || (o === "__proto__" && (Object.defineProperty(i, o, { enumerable: !0, configurable: !0, writable: !0 }), Object.defineProperty(s, o, { enumerable: !0, configurable: !0, writable: !0 })), s[o] = {
      t: u < e.length - 1 && n === 2 ? 3 : n,
      d: !1,
      i: 0,
      c: {}
    });
  }
  if (l = s[o], l.t !== n && !(n === 1 && l.t === 3) || (n === 2 && (l.d || (l.d = !0, i[o] = []), i[o].push(i = {}), l.c[l.i++] = l = { t: 1, d: !1, i: 0, c: {} }), l.d))
    return null;
  if (l.d = !0, n === 1)
    i = a ? i[o] : i[o] = {};
  else if (n === 0 && a)
    return null;
  return [o, i, l.c];
}
function Rc(e) {
  let t = {}, r = {}, n = t, i = r;
  for (let s = ge(e, 0); s < e.length; ) {
    if (e[s] === "[") {
      let o = e[++s] === "[", a = Mt(e, s += +o, "]");
      if (o) {
        if (e[a[1] - 1] !== "]")
          throw new F("expected end of table declaration", {
            toml: e,
            ptr: a[1] - 1
          });
        a[1]++;
      }
      let l = vn(
        a[0],
        t,
        r,
        o ? 2 : 1
        /* Type.EXPLICIT */
      );
      if (!l)
        throw new F("trying to redefine an already defined table or value", {
          toml: e,
          ptr: s
        });
      i = l[2], n = l[1], s = a[1];
    } else {
      let o = Mt(e, s), a = vn(
        o[0],
        n,
        i,
        0
        /* Type.DOTTED */
      );
      if (!a)
        throw new F("trying to redefine an already defined table or value", {
          toml: e,
          ptr: s
        });
      let l = or(e, o[1]);
      a[1][a[0]] = l[0], s = l[1];
    }
    if (s = ge(e, s, !0), e[s] && e[s] !== `
` && e[s] !== "\r")
      throw new F("each key-value declaration must be followed by an end-of-line", {
        toml: e,
        ptr: s
      });
    s = ge(e, s);
  }
  return t;
}
const Ac = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TomlDate: we,
  TomlError: F,
  parse: Rc
}, Symbol.toStringTag, { value: "Module" }));
